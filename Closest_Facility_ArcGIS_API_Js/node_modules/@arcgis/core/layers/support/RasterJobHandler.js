/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import{isSome as r}from"../../core/maybe.js";import{open as o}from"../../core/workers/workers.js";import n from"./PixelBlock.js";class t{constructor(){this._workerThread=null,this._destroyed=!1}async initialize(){const e=await o("RasterWorker");this._destroyed?e.close():this._workerThread=e}destroy(){this._destroyed=!0,this._workerThread&&(this._workerThread.close(),this._workerThread=null)}async convertVectorFieldData(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t=await this._workerThread.invoke("convertVectorFieldData",{pixelBlock:r.pixelBlock.toJSON(),type:r.dataType},o);return t?new n(t):null}async decode(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t=await this._workerThread.invoke("decode",r,o);return t?new n(t):null}async symbolize(o,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const i={extent:o.extent&&o.extent.toJSON(),pixelBlock:r(o.pixelBlock)&&o.pixelBlock.toJSON(),simpleStretchParams:o.simpleStretchParams,bandIds:o.bandIds},a=await this._workerThread.invoke("symbolize",i,t);return a?new n(a):null}async updateSymbolizer(r,o){var n;if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t=null==r||null==(n=r.rendererJSON)?void 0:n.histograms;await Promise.all(this._workerThread.broadcast("updateSymbolizer",{symbolizerJSON:r.toJSON(),histograms:t},o))}async stretch(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(null==r||!r.pixelBlock)return null;const t={srcPixelBlock:r.pixelBlock.toJSON(),stretchParams:r.stretchParams},i=await this._workerThread.invoke("stretch",t,o);return i?new n(i):null}async split(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(null==r||!r.pixelBlock)return null;const t={srcPixelBlock:r.pixelBlock.toJSON(),tileSize:r.tileSize,maximumPyramidLevel:r.maximumPyramidLevel},i=await this._workerThread.invoke("split",t,o);return i&&i.forEach(((e,r)=>{i.set(r,e?n.fromJSON(e):null)})),Promise.resolve(i)}async estimateStatisticsHistograms(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(null==r||!r.pixelBlock)return null;const n={srcPixelBlock:r.pixelBlock.toJSON()},t=await this._workerThread.invoke("estimateStatisticsHistograms",n,o);return Promise.resolve(t)}async mosaicAndTransform(o,t){var i;if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(null==o||null==(i=o.srcPixelBlocks)||!i.length)return null;const a={...o,srcPixelBlocks:o.srcPixelBlocks.map((e=>r(e)?e.toJSON():null))},l=await this._workerThread.invoke("mosaicAndTransform",a,t);return l?new n(l):null}}export{t as default};
