/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import t from"../../../request.js";import r from"../../../core/Error.js";import{JSONSupport as o}from"../../../core/JSONSupport.js";import i from"../../../core/Logger.js";import{isSome as n,isNone as s,unwrap as a}from"../../../core/maybe.js";import{EsriPromiseMixin as l}from"../../../core/Promise.js";import{createAbortController as c,onAbort as u}from"../../../core/promiseUtils.js";import{property as f}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as m}from"../../../core/accessorSupport/decorators/subclass.js";import{sanitizeUrl as h}from"../arcgisLayerUrl.js";import{url as d}from"../commonProperties.js";import g from"../RasterStorageInfo.js";import p from"../TileInfo.js";import{getRasterId as x,getBlock as y,putBlock as I,deleteBlock as w,decreaseRefCount as v}from"./RawBlockCache.js";import{decode as k}from"../rasterFormats/RasterCodec.js";import{mosaic as R,approximateTransform as b}from"../rasterFunctions/pixelUtils.js";import{load as C,projectPoint as M,snapPyramid as T,snapExtent as P,getWorldWrapCount as S,projectResolution as B,projectExtent as F,getProjectionOffsetGrid as j,getRasterDatasetAlignmentInfo as L}from"../rasterFunctions/rasterProjectionHelper.js";import{uvComponentToVector as _}from"../rasterFunctions/vectorFieldUtils.js";import D from"../../../geometry/Point.js";import H from"../../../geometry/Extent.js";let W=class extends(l(o)){constructor(){super(...arguments),this.rasterJobHandler=null,this.datasetName=null,this.datasetFormat=null,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const e=C();this.addResolvingPromise(e),await this.when()}normalizeCtorArgs(e){return e&&e.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:p.create(),...e.ioConfig}}),e}set url(e){this._set("url",h(e,i.getLogger(this.declaredClass)))}async open(e){throw new r("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(e,t,r,o={}){const{tileInfo:i}=o,n=i.lodAt(e),s=this.getTileExtent({x:n.resolution,y:n.resolution},t,r,i.origin,i.spatialReference,i.size);return o=this._getRequestOptionsWithSliceId(o),this.fetchPixels(s,i.size[0],i.size[1],o)}async identify(e,t={}){t=this._getRequestOptionsWithSliceId(t);const{spatialReference:r,extent:o}=this.rasterInfo,{datumTransformation:i}=t;let a=M(e,r,i);if(!o.intersects(a))return{location:a,value:null};if(n(this.rasterInfo.transform)){const e=this.rasterInfo.transform.inverseTransform(a);if(!this.rasterInfo.nativeExtent.intersects(e))return{location:e,value:null};a=e}let l=0;if(t.srcResolution){l=T(t.srcResolution,this.rasterInfo,this.ioConfig.sampling).pyramidLevel}else if(l=await this.computeBestPyramidLevelForLocation(e,t),null==l)return{location:a,value:null};const c=this.identifyPixelLocation(a,l,null);if(null===c)return{location:a,value:null};const{row:u,col:f,rowOffset:m,colOffset:h}=c,d=x(this.url,t.sliceId),g=`${l}/${u}/${f}`;let p=y(d,null,g);s(p)&&(p=this.fetchRawTile(l,u,f,t),I(d,null,g,p));const w=await p;if(s(w)||!w.pixels||0===w.pixels.length)return{location:a,value:null};const v=m*this.rasterInfo.storageInfo.blockHeight+h,k=!w.mask||w.mask[v]?w.pixels.map((e=>e[v])):null,R=this.rasterInfo.dataType;if(("vector-magdir"===R||"vector-uv"===R)&&(null==k?void 0:k.length)>1){return{location:a,value:k,magdirValue:"vector-magdir"===R?[k[0],k[1]]:_([k[0],k[1]]),pyramidLevel:l}}return{location:a,value:k,pyramidLevel:l}}async fetchPixels(e,t,r,o={}){e=P(e);const i=S(e),n=this.rasterInfo.spatialReference,s=!e.spatialReference.equals(n),{datumTransformation:l}=o,c=new D({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/r,spatialReference:e.spatialReference}),u=o.srcResolution||(s?B(c,n,e,l):c);if(!u)return null;const{pyramidLevel:f,pyramidResolution:m,excessiveReading:h}=T(u,this.rasterInfo,this.ioConfig.sampling);if(h)return null;const d=this.rasterInfo.storageInfo;let g=s?F(e,n,l):e;const p=a(this.rasterInfo.transform);if(p&&(g=p.inverseTransform(g)),null==g)return null;const x={x:Math.floor((g.xmin-d.origin.x)/m.x+.1),y:Math.floor((d.origin.y-g.ymax)/m.y+.1)},y=Math.ceil((g.xmax-g.xmin)/m.x-.1),I=Math.ceil((g.ymax-g.ymin)/m.y-.1);if(y/t>8||I/r>8||i>=2)return null;const w=await this.fetchRawPixels(f,x,{width:y,height:I,wrapCount:i},o);if(!w)return null;const v=f>0?d.pyramidBlockWidth:d.blockWidth,k=f>0?d.pyramidBlockHeight:d.blockHeight,C=v===y&&k===I&&x.x%v==0&&x.y%k==0;if(!s&&C&&1===w.pixelBlocks.length&&v===t&&k===r&&u.x===c.x&&u.y===c.y)return{extent:e,srcExtent:g,pixelBlock:w.pixelBlocks[0]};const M=j(e,w.extent,c,l,p,i>0);let L;const _=!o.requestRawData,H={rows:M.spacing[0],cols:M.spacing[1]},W=a(this._getRasterTileAlignmentInfo(f,w.extent.xmin)),{pixelBlocks:A,mosaicSize:O,isPartiallyFilled:z}=w;if(this.rasterJobHandler)L=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:A,srcMosaicSize:O,destDimension:_?{width:t,height:r}:null,coefs:_?M.coefficients:null,sampleSpacing:_?H:null,interpolation:o.interpolation,alignmentInfo:W},o);else{const e=R(A,O,null,null,W);L=_?b(e,{width:t,height:r},M.coefficients,H,o.interpolation):e}return o.requestRawData?{srcExtent:g,pixelBlock:L,transformGrid:M,extent:e,isPartiallyFilled:z}:{srcExtent:g,extent:e,pixelBlock:L}}async fetchRawPixels(e,t,r,o){const{origin:i,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:l}=this.getBlockWidthHeight(e);let{x:c,y:u}=t,{width:f,height:m,wrapCount:h}=r;const d=a(this._getRasterTileAlignmentInfo(e,0));o.buffer&&(c-=o.buffer.cols,u-=o.buffer.rows,f+=2*o.buffer.cols,m+=2*o.buffer.rows);const g=Math.floor(c/s),p=Math.floor(u/l),x=Math.floor((c+f-1)/s),y=Math.floor((u+m-1)/l),I=n[e];if(!I)return null;const{minRow:w,minCol:v,maxCol:k,maxRow:R}=I;if(y<w||x<v||p>R||g>k)return null;const b=new Array;let C=!1;const M=null==this.ioConfig.allowPartialFill?o.allowPartialFill:this.ioConfig.allowPartialFill;for(let a=p;a<=y;a++)for(let t=g;t<=x;t++){const r=0===h||null==d||t<d.worldColumnCountFromOrigin?t:t%d.worldColumnCountFromOrigin-d.originColumnOffset;if(a>=w&&r>=v&&R>=a&&k>=r){const t=this._fetchRawTile(e,a,r,o);M?b.push(new Promise((e=>{t.then((t=>e(t))).catch((()=>{C=!0,e(null)}))}))):b.push(t)}else b.push(null)}if(0===b.length)return null;const T=await Promise.all(b),P={height:(y-p+1)*l,width:(x-g+1)*s},{spatialReference:S}=this.rasterInfo,B=this.getPyramidPixelSize(e),{x:F,y:j}=B;return{extent:new H({xmin:i.x+g*s*F,xmax:i.x+(x+1)*s*F,ymin:i.y-(y+1)*l*j,ymax:i.y-p*l*j,spatialReference:S}),pixelBlocks:T,mosaicSize:P,isPartiallyFilled:C}}fetchRawTile(e,t,o,i){throw new r("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return F(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?k(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,r,o){var i,n;const{customFetchParameters:s}=this.ioConfig,{range:a,query:l,headers:c}=r;o=null!=(i=null!=(n=o)?n:r.retryCount)?i:this.ioConfig.retryCount;const u=a?{Range:`bytes=${a.from}-${a.to}`}:null;try{return await t(e,{...r,query:{...l,...s},headers:{...c,...u}})}catch(f){if(o>0)return o--,this.request(e,r,o);throw f}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;if(!n(t)||null==e||!e.length)return null;let r=0;const o=e[0].variableName;for(let i=0;i<t.variables.length;i++){const n=t.variables[i],s=n.dimensions;if(n.name!==o){r+=s.map((e=>this._getDimensionValuesCount(e))).reduce(((e,t)=>e+t));break}const a=s.map((e=>this._getDimensionValuesCount(e))),l=s.length;for(let t=0;t<l;t++){const o=e.filter((e=>e.dimensionName===s[t].name))[0];if(null==o)return null;const i=Array.isArray(o.values[0])?o.values[0][0]:o.values[0],n=this._getIndexFromDimensions(i,s[t]);if(-1===n)return null;a.shift(),r+=t===l-1?n:n*a.reduce(((e,t)=>e+t))}}return r}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:r,pixelSize:o}=this.rasterInfo;if(!e.tileInfo){const i=[],n=e.maximumPyramidLevel||0;let s=Math.max(o.x,o.y),a=1/.0254*96*s;for(let e=0;e<=n;e++)i.push({level:n-e,resolution:s,scale:a}),s*=2,a*=2;const l=new D({x:r.xmin,y:r.ymax,spatialReference:t});e.tileInfo=new p({origin:l,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:i}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,r=512,o){const{width:i,height:n,nativeExtent:s,pixelSize:a,spatialReference:l}=e,c=new D({x:s.xmin,y:s.ymax,spatialReference:l});null==o&&(o=Math.max(0,Math.round(Math.log(Math.max(i,n))/Math.LN2-8)));const u=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[a],o);e.storageInfo=new g({blockWidth:t,blockHeight:r,pyramidBlockWidth:t,pyramidBlockHeight:r,origin:c,firstPyramidLevel:1,maximumPyramidLevel:o,blockBoundary:u})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,r,o,i,n=0,s=2){if(1===i.length&&n>0){i=[...i];let{x:e,y:t}=i[0];for(let r=0;r<n;r++)e*=s,t*=s,i.push({x:e,y:t})}const a=[],{x:l,y:c}=o;for(let u=0;u<i.length;u++){const{x:o,y:n}=i[u];a.push({minCol:Math.floor((e.xmin-l+.1*o)/t/o),maxCol:Math.floor((e.xmax-l-.1*o)/t/o),minRow:Math.floor((c-e.ymax+.1*n)/r/n),maxRow:Math.floor((c-e.ymin-.1*n)/r/n)})}return a}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:o}=this.rasterInfo.storageInfo;if(0===e)return t;if(n(r)&&r.length)return r[e-1];const i=o**e;return{x:t.x*i,y:t.y*i}}identifyPixelLocation(e,t,r){const{spatialReference:o,nativeExtent:i}=this.rasterInfo,{blockWidth:n,blockHeight:s,maximumPyramidLevel:a,origin:l}=this.rasterInfo.storageInfo,c=M(e,o,r);if(!i.intersects(c))return null;if(t<0||t>a)return null;const u=this.getPyramidPixelSize(t),{x:f,y:m}=u,h=(l.y-c.y)/m/s,d=(c.x-l.x)/f/n,g=Math.min(s-1,Math.floor((h-Math.floor(h))*s)),p=Math.min(n-1,Math.floor((d-Math.floor(d))*n));return{pyramidLevel:t,row:Math.floor(h),col:Math.floor(d),rowOffset:g,colOffset:p,srcLocation:c}}getTileExtent(e,t,r,o,i,n){const[s,a]=n,l=o.x+r*s*e.x,c=l+s*e.x,u=o.y-t*a*e.y,f=u-a*e.y;return new H({xmin:l,xmax:c,ymin:f,ymax:u,spatialReference:i})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,r){const o=this.rasterInfo.storageInfo.blockBoundary[e];return!o||o.maxRow<t||o.maxCol<r||o.minRow>t||o.minCol>r}_fetchRawTile(e,t,r,o){const i=this.rasterInfo.storageInfo.blockBoundary[e];if(!i)return Promise.resolve(null);const{minRow:n,minCol:a,maxCol:l,maxRow:f}=i;if(t<n||r<a||t>f||r>l)return Promise.resolve(null);const m=x(this.url,o.sliceId),h=`${e}/${t}/${r}`;let d=y(m,o.registryId,h);if(s(d)){const i=c();d=this.fetchRawTile(e,t,r,{...o,signal:i.signal}),I(m,o.registryId,h,d,i),d.catch((()=>w(m,o.registryId,h)))}return o.signal&&u(o,(()=>{v(m,o.registryId,h)})),d}_getIndexFromDimensions(e,t){const{extent:r,interval:o,unit:i,values:n}=t;if(null!=n&&n.length)return Array.isArray(n[0])?n.findIndex((t=>t[0]<=e&&t[1]>=e)):n.indexOf(e);if(e>r[1])return-1;const s=r[0];let a=-1;if("ISO8601"===i){var l;switch((null==(l=t.intervalUnit)?void 0:l.toLowerCase())||"seconds"){case"seconds":a=Math.round((e-s)/1e3/o);break;case"minutes":a=Math.round((e-s)/6e4/o);break;case"hours":a=Math.round((e-s)/36e5/o);break;case"days":a=Math.round((e-s)/864e5/o);break;case"years":a=Math.round((new Date(e).getUTCFullYear()-new Date(s).getUTCFullYear())/o);break;case"decades":a=Math.round((new Date(e).getUTCFullYear()-new Date(s).getUTCFullYear())/10/o)}return a}return Math.round((e-s)/o)}_getDimensionValuesCount(e){const{extent:t,interval:r,unit:o,values:i}=e;let n=(null==i?void 0:i.length)||0;if(n)return n;const s=t[0];if(0===n&&"ISO8601"===o){var a;switch((null==(a=e.intervalUnit)?void 0:a.toLowerCase())||"seconds"){case"seconds":n=Math.round((t[1]-t[0])/1e3/r);break;case"minutes":n=Math.round((t[1]-t[0])/6e4/r);break;case"hours":n=Math.round((t[1]-t[0])/36e5/r);break;case"days":n=Math.round((t[1]-t[0])/864e5/r);break;case"years":n=Math.round((new Date(t[1]).getUTCFullYear()-new Date(s).getUTCFullYear())/r);break;case"decades":n=Math.round((new Date(t[1]).getUTCFullYear()-new Date(s).getUTCFullYear())/10/r)}return n}return Math.round((t[1]-t[0])/r)}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=L(this.rasterInfo)),n(this._rasterTileAlighmentInfo.pyramidsInfo)?{startX:t,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[e]}:null}_getRequestOptionsWithSliceId(e){var t;return null!=(t=e.multidimensionalDefinition)&&t.length&&n(this.rasterInfo.multidimensionalInfo)&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)||0}),e}};e([f()],W.prototype,"_rasterTileAlighmentInfo",void 0),e([f(d)],W.prototype,"url",null),e([f({type:String,json:{write:!0}})],W.prototype,"datasetName",void 0),e([f({type:String,json:{write:!0}})],W.prototype,"datasetFormat",void 0),e([f()],W.prototype,"rasterInfo",void 0),e([f()],W.prototype,"ioConfig",void 0),e([f()],W.prototype,"sourceJSON",void 0),W=e([m("esri.layers.support.rasterDatasets.BaseRaster")],W);var A=W;export{A as default};
