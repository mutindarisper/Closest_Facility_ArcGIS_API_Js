/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import"../../geometry.js";import t from"../../Graphic.js";import{isSome as r,unwrap as o}from"../../core/maybe.js";import{property as s}from"../../core/accessorSupport/decorators/property.js";import"../../core/has.js";import"../../core/accessorSupport/ensureType.js";import"../../core/Logger.js";import{reader as a}from"../../core/accessorSupport/decorators/reader.js";import{subclass as p}from"../../core/accessorSupport/decorators/subclass.js";import n from"./FeatureSet.js";import i from"../../geometry/Extent.js";import m from"../../geometry/SpatialReference.js";import l from"../../geometry/Point.js";import u from"../../geometry/Polyline.js";let c=class extends n{constructor(e){super(e),this.extent=null,this.features=null,this.geometryType="polyline",this.routeId=null,this.routeName=null,this.totalDriveTime=null,this.totalLength=null,this.totalTime=null}readFeatures(e,s){(e||[]).forEach((e=>{this._decompressFeatureGeometry(e,s.summary.envelope.spatialReference)}));const a=m.fromJSON(s.spatialReference);return e.map((e=>{const s=t.fromJSON(e),p=r(e.geometry)&&e.geometry.spatialReference;return s.geometry&&!p&&(o(s.geometry).spatialReference=a),s.strings=e.strings,s.events=(e.events||[]).map((o=>{const s=new t({geometry:new l({x:o.point.x,y:o.point.y,z:o.point.z,hasZ:void 0!==o.point.z,spatialReference:r(e.geometry)&&e.geometry.spatialReference}),attributes:{ETA:o.ETA,arriveTimeUTC:o.arriveTimeUTC}});return s.strings=o.strings,s})),s}))}get mergedGeometry(){if(!this.features)return null;const e=this.features.map((({geometry:e})=>o(e))),t=this.get("extent.spatialReference");return this._mergePolylinesToSinglePath(e,t)}get strings(){return this.features.map((({strings:e})=>e))}_decompressFeatureGeometry(e,t){e.geometry=this._decompressGeometry(e.compressedGeometry,t)}_decompressGeometry(e,t){let r=0,o=0,s=0,a=0;const p=[];let n,i,m,l,u,c,y,g,h=0,f=0,d=0;if(u=e.match(/((\+|\-)[^\+\-\|]+|\|)/g),u||(u=[]),0===parseInt(u[h],32)){h=2;const e=parseInt(u[h],32);h++,c=parseInt(u[h],32),h++,1&e&&(f=u.indexOf("|")+1,y=parseInt(u[f],32),f++),2&e&&(d=u.indexOf("|",f)+1,g=parseInt(u[d],32),d++)}else c=parseInt(u[h],32),h++;for(;h<u.length&&"|"!==u[h];){n=parseInt(u[h],32)+r,h++,r=n,i=parseInt(u[h],32)+o,h++,o=i;const e=[n/c,i/c];f&&(l=parseInt(u[f],32)+s,f++,s=l,e.push(l/y)),d&&(m=parseInt(u[d],32)+a,d++,a=m,e.push(m/g)),p.push(e)}return{paths:[p],hasZ:f>0,hasM:d>0,spatialReference:t}}_mergePolylinesToSinglePath(e,t){let r=[];(e||[]).forEach((e=>{e.paths.forEach((e=>{r=r.concat(e)}))}));const o=[];let s=[0,0];return r.forEach((e=>{e[0]===s[0]&&e[1]===s[1]||(o.push(e),s=e)})),new u({paths:[o]},t)}};e([s({type:i,json:{read:{source:"summary.envelope"}}})],c.prototype,"extent",void 0),e([s()],c.prototype,"features",void 0),e([a("features")],c.prototype,"readFeatures",null),e([s()],c.prototype,"geometryType",void 0),e([s({readOnly:!0})],c.prototype,"mergedGeometry",null),e([s()],c.prototype,"routeId",void 0),e([s()],c.prototype,"routeName",void 0),e([s({value:null,readOnly:!0})],c.prototype,"strings",null),e([s({json:{read:{source:"summary.totalDriveTime"}}})],c.prototype,"totalDriveTime",void 0),e([s({json:{read:{source:"summary.totalLength"}}})],c.prototype,"totalLength",void 0),e([s({json:{read:{source:"summary.totalTime"}}})],c.prototype,"totalTime",void 0),c=e([p("esri.rest.support.DirectionsFeatureSet")],c);var y=c;export{y as default};
