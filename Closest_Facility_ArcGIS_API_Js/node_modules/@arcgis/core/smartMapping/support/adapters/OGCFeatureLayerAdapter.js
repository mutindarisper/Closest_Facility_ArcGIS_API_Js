/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import{pickRandom as r}from"../../../core/arrayUtils.js";import t from"../../../core/Error.js";import{unwrap as s}from"../../../core/maybe.js";import{whenFalseOnce as a}from"../../../core/watchUtils.js";import"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/Logger.js";import{subclass as i}from"../../../core/accessorSupport/decorators/subclass.js";import{isDateField as o}from"../../../layers/support/fieldUtils.js";import{getArcadeForPredominantCategory as n}from"../../statistics/support/predominanceUtils.js";import{mergeWhereClauses as u}from"../../statistics/support/utils.js";import{WorkerClient as p}from"../../statistics/support/WorkerClient.js";import l from"./FeatureLayerAdapter.js";import{getSummaryStatisticsFromFeatureSet as c,processSummaryStatisticsResult as d,getUniqueValuesFromFeatureSet as m,createUVResult as y,getPredominantCategoriesFromUVInfos as h,getMissingFields as f}from"./support/utils.js";let w=class extends l{constructor(e){super(e)}async _waitForLayerViewUpdate(e){if(!e)throw new t("ogc-feature-layer-adapter:insufficient-data","layerView is required to fetch the features");await a(e,"updating")}async _summaryStatsFromClientQuery(e,r){const{signal:s,view:i}=e;if(!i)throw new t("ogc-feature-layer-adapter:insufficient-data","view is required to fetch the features from layerView");const o=this._getSummaryStatsQuery(e,r),n=await i.whenLayerView(this.layer);await a(n,"updating");const u=await n.queryFeatures(o,{signal:s}),p=c(u,r);return d(p)}async _uvFromClientQuery(e,r){const{signal:s,view:i}=e;if(!i)throw new t("ogc-feature-layer-adapter:insufficient-data","view is required to fetch the features from layerView");const o=this._getUVQuery(e),n=await i.whenLayerView(this.layer);await a(n,"updating");const u=await n.queryFeatures(o,{signal:s}),p=await m(u,this,e.field,e.view,null,s);return y(p,r,e.returnAllCodedValues)}summaryStatistics(e){const{field:r,valueExpression:s,sqlExpression:a,features:i,view:n}=e,u=r?this.getField(r):null,p=o(u),l=!!s,c="3d"===(null==n?void 0:n.type);if(a&&!this.supportsSQLExpression)throw new t("ogc-feature-layer-adapter:not-supported","Layer does not support standardized SQL expression for queries");return l||i||c?this._summaryStatsFromMemory(e,u):this._summaryStatsFromClientQuery(e,p)}uniqueValues(e){const{field:r,valueExpression:s,sqlExpression:a,features:i,view:o}=e,n=(r?this.getField(r):null)&&this.getFieldDomain(r),u=!!s,p="3d"===(null==o?void 0:o.type);if(a&&!this.supportsSQLExpression)throw new t("ogc-feature-layer-adapter:not-supported","Layer does not support standardized SQL expression for queries");return u||i||p?this._uvFromMemory(e,n):this._uvFromClientQuery(e,n)}histogram(e){const{features:r,valueExpression:s,normalizationType:a,sqlExpression:i}=e,o=r||!!s;if(i&&!this.supportsSQLExpression)throw new t("ogc-feature-layer-adapter:not-supported","Layer does not support standardized SQL expression for queries");return o||a?this._histogramFromMemory(e):this._histogramForField(e)}classBreaks(e){return!1!==e.analyzeData?this._classBreaksFromMemory(e):this._classBreaksFromInterpolation(e)}async queryFeatureCount(e){const{whereClause:r,view:s,signal:i}=e;if(!s)throw new t("ogc-feature-layer-adapter:insufficient-data","view is required to fetch the features from layerView");const o=this.layer.createQuery();o.where=u(o.where,r);const n=await s.whenLayerView(this.layer);return await a(n,"updating"),n.queryFeatureCount(o,{signal:i})}generateRenderer(e,r){throw new t("ogc-feature-layer-adapter:not-supported","OGCFeatureLayer does not support generateRenderer operation")}async predominantCategories(e){const{fields:r,view:t,signal:s}=e,a=n(r),i=await this._uvFromMemory({valueExpression:a,view:t,signal:s});return h(i.uniqueValueInfos,r)}async getSampleFeatures(e,s){const{view:a,sampleSize:i,requiredFields:o,returnGeometry:n,signal:u}=e,p=this.layer.createQuery(),l=1;if(p.outSpatialReference=e.spatialReference||a&&a.spatialReference,p.returnGeometry=!!n,p.outFields=o,!a)throw new t("ogc-feature-layer-adapter:not-supported","view is required to get sample features for OGCFeatureLayer");const c=await a.whenLayerView(this.layer);if((await f(this,o,c)).length)throw new t("ogc-feature-layer-adapter:not-supported","Required fields need to be passed in the outFields for OGCFeatureLayer");const d=await this._fetchFeaturesFromMemory(c,p,u,s);return r(d,i>0&&i<=d.length?i:d.length,l)}load(e){const r=this.layer.load(e).then((async r=>{this.geometryType=r.geometryType,this.objectIdField=r.objectIdField,this.supportsSQLExpression=r.get("capabilities.query.supportsSqlExpression"),this.minScale=r.minScale,this.maxScale=r.maxScale,this.fullExtent=r.fullExtent,this.workerClient=p.getInstance(),await this.workerClient.open(s(s(e).signal))}));return this.addResolvingPromise(r),Promise.resolve(this)}};w=e([i("esri.smartMapping.support.adapters.OGCFeatureLayerAdapter")],w);var g=w;export{g as default};
