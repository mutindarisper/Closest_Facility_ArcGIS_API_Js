/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{throwIfAborted as n}from"../../../../core/promiseUtils.js";import{createKernel as t,createValueFunction as e}from"../../../../renderers/support/heatmapUtils.js";import a from"../../../../rest/support/ClassBreaksDefinition.js";import{createGenerateRendererClassBreaks as o}from"../../../../rest/support/generateRendererUtils.js";import{noDominantCategoryField as i}from"../../../statistics/support/predominanceUtils.js";import{isIntegerField as l,castIntegerFieldToFloat as r,getDateDiffSQL as u}from"../../utils.js";import{loadArcade as s}from"../../../../support/arcadeOnDemand.js";const c=/_value$/i,m=/\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*/gi,f=5,d=10,p=Math.LOG10E,v="equal-interval",h=1,x=["min","max","avg","stddev","count","sum","variance","nullcount"];let g=null;function V(n){return n.map((n=>n.toJSON()))}async function y(n,t,e){const a=[];if(t)for(const o of t){const t=n.getField(o);"availableFields"in e&&-1===e.availableFields.indexOf(t.name)&&a.push(t.name)}return a}function b(n,t){const e=n&&n.features,a=e&&e[0]&&e[0].attributes,o={};for(const i in a)o[i.replace(c,"").toLowerCase()]=a[i];return null!=o.totalcount&&o.totalcount>=o.count&&(o.nullcount=o.totalcount-o.count),delete o.totalcount,o.min===o.max&&null!=o.min&&null==o.stddev&&(o.stddev=o.variance=0),t&&(["min","max","avg","stddev","sum","variance"].forEach((n=>{null!=o[n]&&(o[n]=Math.ceil(o[n]))})),o.min===o.max&&null!=o.min&&(o.avg=o.min,o.stddev=o.variance=0)),o}async function T(n,t,e){let a=await z(n,t);a=F(a,n.minValue,n.maxValue);const o=I(a,!n.normalizationType);return e&&["avg","stddev","variance"].forEach((n=>{null!=o[n]&&(o[n]=Math.ceil(o[n]))})),o}function F(n,t,e){return t=null==t?-1/0:t,e=null==e?1/0:e,n.filter((n=>Number.isFinite(n)&&n>=t&&n<=e))}async function z(n,t){const e=n.field,a="function"==typeof e,o=n.valueExpression,i=n.normalizationType,l=n.normalizationField,r=n.normalizationTotal,u=[],c=n.view;let m=null,f=null;if(o){if(!g){const{arcadeUtils:n}=await s();g=n}m=g.createFunction(o),f=c&&g.getViewInfo({viewingMode:"2d"===c.type?"map":c.viewingMode,scale:c.scale,spatialReference:c.spatialReference})}return t?(t.forEach((n=>{const t=n.attributes;let s;if(o){const t=g.createExecContext(n,f);s=g.executeFunction(m,t)}else a?s=e.call(null,n):t&&(s=t[e]);if(i&&Number.isFinite(s)){const n=t&&parseFloat(t[l]),e=s;s=null,"log"===i&&0!==e?s=Math.log(e)*Math.LOG10E:"percent-of-total"===i&&Number.isFinite(r)&&0!==r?s=e/r*100:"field"===i&&Number.isFinite(n)&&0!==n?s=e/n:"natural-log"===i&&e>0?s=Math.log(e):"square-root"===i&&e>0&&(s=e**.5)}u.push(s)})),u):u}function I(n,t){let e=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY,o=null,i=null,l=null,r=null;for(const s of n)o+=s,e=Math.min(e,s),a=Math.max(a,s);const u=n.length;if(u){i=o/u;let e=0;for(const t of n)e+=(t-i)**2;r=t?u>1?e/(u-1):0:u>0?e/u:0,l=Math.sqrt(r)}else e=null,a=null;return{avg:i,count:u,max:a,min:e,stddev:l,sum:o,variance:r}}function w(n){let t;for(t in n)x.indexOf(t)>-1&&(Number.isFinite(n[t])||(n[t]=null));return n}function E(n){const t=n.field,e=n.classificationMethod||v,o=n.normalizationType,i=n.normalizationField,l=new a;return l.classificationField=t,l.breakCount=n.breakCount,l.classificationMethod=e,l.standardDeviationInterval="standard-deviation"===e?n.standardDeviationInterval||h:void 0,l.normalizationType=o,l.normalizationField="field"===o?i:void 0,l}function M(n,a=10,o,i,l,r){const u=new Float64Array(l*r),s=t(a),c=Math.round(3*a);let m=Number.POSITIVE_INFINITY,f=Number.NEGATIVE_INFINITY,d=0,p=0,v=0,h=0;const x=e(i,o);for(const{geometry:t,attributes:e}of n){const n=t.x-c,a=t.y-c,o=Math.max(0,n),i=Math.max(0,a),g=Math.min(r,t.y+c),V=Math.min(l,t.x+c),y=+x(e);for(let t=i;t<g;t++){const e=s[t-a];for(let a=o;a<V;a++){const o=s[a-n],i=t*l+a,r=u[i];d=u[i]+=e*o*y;const c=d-r;p+=c,v+=c*c,d<m&&(m=d),d>f&&(f=d),h++}}}if(!h)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const g=(f-m)/2;return{mean:p/h,stdDev:Math.sqrt((v-p*p/h)/h),min:m,max:f,mid:g,count:h}}async function N(n,t){const e=n.normalizationTotal,a=E({field:n.field,normalizationType:n.normalizationType,normalizationField:n.normalizationField,classificationMethod:n.classificationMethod,standardDeviationInterval:n.standardDeviationInterval,breakCount:n.numClasses||f});let i=await z(n,t);i=F(i,n.minValue,n.maxValue);return O(n,o({definition:a,values:i,normalizationTotal:e}))}function O(n,t){let e=t.classBreaks;const a=e.length,o=e[0].minValue,i=e[a-1].maxValue,l="standard-deviation"===n.classificationMethod,r=m;return e=e.map((n=>{const t=n.label,e={minValue:n.minValue,maxValue:n.maxValue,label:t};if(l&&t){const n=t.match(r).map((n=>+n.trim()));2===n.length?(e.minStdDev=n[0],e.maxStdDev=n[1],n[0]<0&&n[1]>0&&(e.hasAvg=!0)):1===n.length&&(t.indexOf("<")>-1?(e.minStdDev=null,e.maxStdDev=n[0]):t.indexOf(">")>-1&&(e.minStdDev=n[0],e.maxStdDev=null))}return e})),{minValue:o,maxValue:i,classBreakInfos:e,normalizationTotal:t.normalizationTotal}}function C(n,t,e){const a=(t-n)/e,o=[];let i,l=n;for(let r=1;r<=e;r++)i=l+a,i=Number(i.toFixed(16)),o.push([l,r===e?t:i]),l=i;return o}function D(n){const t=[],e=n.classBreaks,a=e[0].minValue,o=e[e.length-1].maxValue;e.forEach((n=>{t.push([n.minValue,n.maxValue])}));const i={field:n.field,normalizationType:n.normalizationType,normalizationField:n.normalizationField,normalizationTotal:n.normalizationTotal,layer:n.layer};return{min:a,max:o,intervals:t,sqlExpr:k(i),excludeZerosExpr:n.where,normTotal:n.normalizationTotal}}function k(n){const{field:t,normalizationType:e,normalizationField:a,normalizationTotal:o,layer:i}=n,u=l(i,t);let s=t;return"percent-of-total"===e?s=`((${u?r(t):t} / ${o}) * 100)`:"log"===e?s=`(log(${t}) * ${p})`:"field"===e?s=`(${u?r(t):t} / ${a})`:"natural-log"===e?s=`(log(${u?r(t):t}))`:"square-root"===e&&(s=`(power(${u?r(t):t}, 0.5))`),s}async function S(n,t,e){const{min:a,max:o,normTotal:i}=t,l=n.numBins||d,r=t.intervals||C(a,o,l),u=r.map(((n,t)=>({minValue:r[t][0],maxValue:r[t][1],count:0}))),s=await z(n,e);for(const c of s)if(null!=c&&c>=a&&c<=o){const n=q(r,c);n>-1&&u[n].count++}return{bins:u,minValue:a,maxValue:o,normalizationTotal:i}}function q(n,t){let e=-1;for(let a=n.length-1;a>=0;a--){if(t>=n[a][0]){e=a;break}}return e}function L(n,t){let e;if(t=t.toLowerCase(),n)for(const a in n)if(a.toLowerCase()!==t){e=n[a];break}return e}function $(n,t){let e;if(t=t.toLowerCase(),n)for(const a in n)if(a.toLowerCase()===t){e=n[a];break}return e}function j(n,t,e,a,o){const i={},l="countOFExpr";n&&n.features&&n.features.forEach((n=>{const t=n.attributes,e=L(t,l),a=$(t,l);0!==e&&(i[e]=a)}));const r=[];return C(t,e,a).forEach(((n,t)=>{const e=(t+1).toString();r.push({minValue:n[0],maxValue:n[1],count:i.hasOwnProperty(e)?i[e]:0})})),{bins:r,minValue:t,maxValue:e,normalizationTotal:o}}function U(t,e,a,o,i,l){const r=t&&t.features,u="countOF"+(a||"Expr"),s={};let c=!1;if(r.forEach((n=>{const t=n.attributes,e=$(t,u);let o=a?$(t,a):L(t,u);null===o&&0===e&&(c=!0),(null==o||"string"==typeof o&&""===o.trim())&&(o=null),null==s[o]?s[o]={count:e,data:o}:s[o].count=s[o].count+e})),a&&c){const t=a+" is NULL";return e.queryFeatureCount({whereClause:t,view:o,signal:l}).then((n=>(n=n||0,s.null.count=s.null.count+n,A(s,i)))).catch((()=>(n(l),A(s,i))))}return Promise.resolve(A(s,i))}function A(n,t){if(t)for(const e in n)n[e].label=t[e];return{count:n}}function B(n,t,e){const a=n.count,o=[];if(e&&t&&"coded-value"===t.type){t.codedValues.forEach((n=>{const t=n.code;a.hasOwnProperty(t)||(a[t]={data:t,count:0})}))}for(const i in a){const n=a[i];o.push({value:n.data,count:n.count,label:n.label})}return{uniqueValueInfos:o}}async function P(n,t,e){const a=await z(n,t),o={};for(let i of a)(null==i||"string"==typeof i&&""===i.trim())&&(i=null),null==o[i]?o[i]={count:1,data:i}:o[i].count++;return B({count:o},e,n.returnAllCodedValues)}function _(n,t){return u(n,new Date(0),t,"milliseconds").sqlExpression}function G(n,t){const e=n.map((n=>n.value)),a=t.filter((n=>-1===e.indexOf(n)));for(const o of a)n.push({value:o,count:0});n.sort(((n,e)=>t.indexOf(n.value)-t.indexOf(e.value)));for(const o of n)o.value===i&&(o.value=null);return{predominantCategoryInfos:n}}export{N as calculateClassBreaksFromMemory,M as calculateHeatmapStats,S as calculateHistogramFromMemory,T as calculateStatsFromMemory,P as calculateUniqueValuesFromMemory,E as createCBDefn,B as createUVResult,V as ensureFeaturesJSON,D as generateBinParams,z as getDataValues,C as getEqualIntervalBins,k as getFieldExpr,j as getHistogramFromFeatureSet,y as getMissingFields,G as getPredominantCategoriesFromUVInfos,b as getSummaryStatisticsFromFeatureSet,U as getUniqueValuesFromFeatureSet,_ as msSinceUnixEpochSQL,w as processSummaryStatisticsResult,O as resolveCBResult,x as statisticTypes};
