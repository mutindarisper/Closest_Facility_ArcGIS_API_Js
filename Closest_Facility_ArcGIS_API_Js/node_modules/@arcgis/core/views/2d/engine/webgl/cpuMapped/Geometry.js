/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{unwrapOrThrow as e,isNone as t}from"../../../../../core/maybe.js";import"../../../../webgl/BufferObject.js";import"../../../../webgl/FramebufferObject.js";import"../../../../../core/has.js";import"../../../../webgl/checkWebGLError.js";import"../../../../webgl/enums.js";import"../../../../../chunks/builtins.js";import"../../../../webgl/renderState.js";import"../../../../webgl/Texture.js";import r from"../../../../webgl/VertexArrayObject.js";import{FeatureDisplayList as i}from"../FeatureDisplayList.js";import{Buffer as s}from"./Buffer.js";import{DisplayRecordReader as o}from"./DisplayRecordReader.js";class n{constructor(e,t){this._indicesInvalid=!1,this.geometryType=e}destroy(){this._vao&&(this._vao.dispose(),this._vao=null)}insert(t,r,i){if(!t.records.byteLength)return;const n=t.stride;if(this._vertexBuffer&&this._indexBuffer){const i=4*t.indices.byteLength,s=t.vertices.byteLength/n;this._indexBuffer.ensure(i),this._vertexBuffer.ensure(s);const{vertices:f,indices:d}=t,h=o.from(t.records),u=this._vertexBuffer.insert(f,0,f.byteLength/n,0),c=this._indexBuffer.insert(d,0,d.byteLength/4,u);if(h.forEach((e=>{e.indexFrom+=c,e.vertexFrom+=u})),e(this._records,"Expected records to be defined").link(h),r)this._indicesInvalid=!0;else if(this._displayList){const e=h.getCursor();for(;e.next();)this._displayList.addRecord(e)}}else{const e=4*t.indices.byteLength,i=t.vertices.byteLength/n,f=n/Uint32Array.BYTES_PER_ELEMENT;this._records=o.from(t.records),this._indexBuffer=new s("index",e,1),this._vertexBuffer=new s("vertex",i,f),this._indexBuffer.insert(t.indices,0,t.indices.byteLength/4,0),this._vertexBuffer.insert(t.vertices,0,t.vertices.byteLength/n,0),r&&(this._indicesInvalid=!0)}}remove(e){if(!t(this._records))for(const t of e){const e=this._records.getCursor();if(!e.lookup(t))continue;const r=e.indexFrom,i=e.vertexFrom;let s=e.indexCount,o=e.vertexCount;for(;e.next()&&e.id===t;)s+=e.indexCount,o+=e.vertexCount;this._indexBuffer.free(r,s),this._vertexBuffer.free(i,o,!0),this._records.delete(t)}}draw(e,i,s,o,n){if(!this._vertexBuffer||!this._indexBuffer||t(this._records))return;if((t(this._vertexBuffer.gpu)||t(this._indexBuffer.gpu))&&(this._vao&&(this._vao.dispose(),this._vao=null),this._vertexBuffer.gpu=null,this._indexBuffer.gpu=null),this._vertexBuffer.upload(e),this._indexBuffer.upload(e),!this._vao){const t=this._vertexBuffer.gpu,o=this._indexBuffer.gpu;if(!o||!t)return;this._vao=new r(e,s,i,{geometry:t},o)}const f=this._vao,d=o*Uint32Array.BYTES_PER_ELEMENT;e.bindVAO(f),e.drawElements(4,n,5125,d)}forEachCommand(e){if(!t(this._records)){if(this._sortIndices(this._records),!this._displayList){const e=this._cursorIndexOrder;this._displayList=i.from(this,this.geometryType,this._records.getCursor(),e)}this._displayList.forEach(e)}}_sortIndices(e){if(!this._indicesInvalid)return;this._indicesInvalid=!1;let t=0;const r=e.getCursor(),i=this._indexBuffer.getBuffer(),s=[],o=[],n=[];for(;r.next();)o.push(r.index),n.push(r.sortKey),s.push(r.id);o.sort(((e,t)=>{const r=n[t],i=n[e];return i===r?s[t]-s[e]:r-i}));const f=e.getCursor();for(const d of o){if(!f.seekIndex(d))throw new Error("Expected to find index");const{indexFrom:e,indexCount:r}=f;f.indexFrom=t;for(let s=0;s<r;s++)this._indexBuffer.set(t++,i[e+s])}this._cursorIndexOrder=o,this._displayList=null}}export{n as Geometry};
