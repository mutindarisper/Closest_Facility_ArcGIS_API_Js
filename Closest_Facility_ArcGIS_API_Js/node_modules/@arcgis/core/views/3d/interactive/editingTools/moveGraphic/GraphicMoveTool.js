/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import e from"../../../../../core/Collection.js";import i from"../../../../../core/Evented.js";import{HandleOwnerMixin as a}from"../../../../../core/HandleOwner.js";import n from"../../../../../core/Handles.js";import{makeHandle as o}from"../../../../../core/handleUtils.js";import{unwrap as s,isNone as r,isSome as p}from"../../../../../core/maybe.js";import{property as l}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/Logger.js";import{subclass as h}from"../../../../../core/accessorSupport/decorators/subclass.js";import{makeDehydratedPoint as c}from"../../../../../layers/graphics/dehydratedFeatures.js";import{getGraphicEffectiveElevationInfo as m,getConvertedElevation as u}from"../../../../../support/elevationInfoUtils.js";import{getGraphicAttachmentOrigin as g}from"../../manipulatorUtils.js";import{SnappingVisualizer3D as d}from"../../SnappingVisualizer3D.js";import{canMoveZ as v}from"../manipulatorUtils.js";import{createVisualElements as f}from"../visualElementUtils.js";import{DISC_RADIUS as y}from"../manipulations/config.js";import{MoveManipulation as M}from"../manipulations/MoveManipulation.js";import{shapeOrientation as w}from"../manipulations/moveUtils.js";import{MoveXYGraphicManipulation as j}from"../manipulations/MoveXYGraphicManipulation.js";import{isSupportedGraphic as b}from"./isSupportedGraphic.js";import{OutlineVisualElement as x}from"../../visualElements/OutlineVisualElement.js";import{GraphicState as S}from"../../../layers/graphics/GraphicState.js";import{dragGraphicMany as E,resetGraphicMany as _}from"../../../../interactive/dragEventPipeline.js";import{InteractiveToolBase as P}from"../../../../interactive/InteractiveToolBase.js";import{EditGeometryOperations as A}from"../../../../interactive/editGeometry/EditGeometryOperations.js";import{SnappingContext as D}from"../../../../interactive/snapping/SnappingContext.js";import{SnappingPipeline as G}from"../../../../interactive/snapping/SnappingDragPipelineStep.js";class O{constructor(t){this.allGraphics=t,this.type="graphic-move-start"}}class z{constructor(t,e,i){this.dx=t,this.dy=e,this.allGraphics=i,this.type="graphic-move"}}class H{constructor(t){this.allGraphics=t,this.type="graphic-move-stop"}}let X=class extends(a(i.EventedMixin(P))){constructor(t){super(t),this.graphics=new e,this.enableZ=!0,this.type="move-3d",this._toolHandles=new n,this.snappingPipeline=new G}initialize(){this._toolHandles.add([this.graphics.on("change",(()=>this._refreshManipulators()))]),this._refreshManipulators(),this.complete()}destroy(){this._toolHandles.destroy(),this._toolHandles=null,this.graphics.removeAll(),this._set("view",null)}get updating(){return this.updatingHandles.updating}reset(){}_refreshManipulators(){this.handles.removeAll(),this._moveManipulation&&this._moveManipulation.destroy(),this.manipulators.removeAll();const t=this.graphics.toArray().filter((t=>0===b(t))).map((t=>new Y(t)));t.length&&(this.createManipulators(t),this.createVisualElements(t),this.handles.add(t.map((t=>this.view.trackGraphicState(t.state)))),this.updateMoveManipulation(t))}createManipulators(t){for(const e of t){const i=e.state;e.manipulationXY=new j({tool:this,view:this.view,graphicState:i}),e.manipulationXY.forEachManipulator((t=>this.handles.add(t.events.on("immediate-click",(t=>{this.emit("immediate-click",{...t,graphic:i.graphic}),t.stopPropagation()}))))),this.handles.add(e.manipulationXY.createDragPipeline(((e,i,a,n)=>this.buildDragEventPipeline(t,0,e,i,a,n))))}this.createMoveManipulation(t)}createMoveManipulation(t){const e=new M({tool:this,view:this.view,snapToScene:!1,xyAvailable:!0,xyAxisAvailable:!0,zAvailable:!0,radius:1===t.length?M.radiusForSymbol(t[0].graphic.symbol):y});this._moveManipulation=e,e.elevationInfo={mode:"absolute-height",offset:0},e.forEachManipulator((t=>{this.handles.add(t.events.on("immediate-click",(i=>{e.zManipulation.hasManipulator(t)||1!==this.graphics.length||this.emit("immediate-click",{...i,graphic:this.graphics.getItemAt(0)}),i.stopPropagation()})))}));const i=()=>this.updateMoveManipulation(t);for(const n of t)this.handles.add([n.state.on("changed",i),n.state.watch("displaying",i)]);const a=t[t.length-1];this.handles.add(a.state.on("changed",(()=>this.updateMoveManipulationAngle(a)))),this.handles.add(e.createDragPipeline(((e,i,a,n,o)=>this.buildDragEventPipeline(t,e,i,a,n,o)),m(a.graphic),s(a.graphic.geometry).spatialReference,a.graphic)),this.updateMoveManipulationAngle(a)}createVisualElements(t){for(const e of t){const i=e.graphic,a=f({view:this.view,graphic:i,forEachManipulator:t=>{e.manipulationXY.forEachManipulator(t),this._moveManipulation.forEachManipulator(t)},onManipulatorsChanged:()=>o()});r(a)||(e.geometryRepresentation=a.visualElement,e.geometryRepresentation instanceof x&&this.handles.add([e.geometryRepresentation.events.on("attachment-origin-changed",(()=>{e.state.isDraped||this.updateMoveManipulation(t)})),e.state.watch("isDraped",(()=>this.updateMoveManipulation(t)))]),this.handles.add(a))}}updateMoveManipulationAngle(t){this._moveManipulation.angleDeferred=()=>w(t.graphic.geometry)}updateMoveManipulation(t){const e=c(0,0,0,this.view.spatialReference);let i=0,a=!1;const n=this._moveManipulation;for(const o of t){if(!o.state.displaying)continue;const t=o.state.graphic;this.enableZ&&v(t)&&(a=!0);const n=o.geometryRepresentation instanceof x&&!o.state.isDraped?o.geometryRepresentation.attachmentOrigin:g(this.view,t);p(n)&&(e.x+=n.x,e.y+=n.y,e.z+=n.z,i++)}i>0?(e.x/=i,e.y/=i,e.z/=i,n.location=e,n.xyManipulation.available=!0,n.xyAxisManipulation.available=!0,n.zManipulation.available=a):n.available=!1}buildDragEventPipeline(t,e,i,a,n,o){const s=[],r=[];let p=null,l=null;const h=()=>{for(const t of s)t.dragging=!1;s.length=0,r.length=0,p=null,l=null,this._moveManipulation.interactive=!0};if(1===t.length&&0===e){const e=t[0].graphic;a=this.buildSnappingPipelineSteps(e,m(e),a,n,o)}const c=a.next((e=>{if("start"===e.action){s.length=0,r.length=0;for(const e of t)e.dragging||!e.manipulationXY.hasManipulator(i)&&e.manipulationXY.grabbing||(s.push(e),r.push(e.graphic),e.dragging=!0);if(0!==r.length&&(this._moveManipulation.interactive=!1,p=E(r,this.view.state.viewingMode),l=_(r),this.emit("graphic-move-start",new O(r)),this.destroyed))return null}return 0!==r.length?e:null})).next((t=>p(t))).next((t=>{switch(t.action){case"start":case"update":if(t.translationX||t.translationY||t.translationZ){const e=this.view.toScreen(t.mapStart),i=this.view.toScreen(t.mapEnd),a=i.x-e.x,n=i.y-e.y;if(this.emit("graphic-move",new z(a,n,r)),this.destroyed)return null}break;case"end":if(this.emit("graphic-move-stop",new H(r)),this.destroyed)return null;h()}}));return n.next((t=>l(t))).next((()=>{if(this.emit("graphic-move-stop",new H(r)),this.destroyed)return null;h()})),c}buildSnappingPipelineSteps(t,e,i,a,n){const o=t.geometry;if(r(o)||"point"!==o.type&&"mesh"!==o.type)return i;const s=("point"===o.type?o:o.anchor).clone(),p=new D({elevationInfo:e,pointer:n,editGeometryOperations:A.fromGeometry(s,this.view.state.viewingMode),visualizer:new d,excludeFeature:t}),l=this.snappingManager;return i.next((e=>{s.z=u(this.view,s,m(t),{mode:"absolute-height",offset:0});return{...e,snapOrigin:p.coordinateHelper.pointToVector(s)}})).next(this.snappingPipeline.createSnapDragEventPipelineStep({snappingContext:p,snappingManager:l,cancel:a,updatingHandles:this.updatingHandles}),this.snappingPipeline.next)}};t([l({constructOnly:!0,nonNullable:!0})],X.prototype,"view",void 0),t([l({readOnly:!0})],X.prototype,"graphics",void 0),t([l({constructOnly:!0,nonNullable:!0})],X.prototype,"enableZ",void 0),t([l({constructOnly:!0})],X.prototype,"snappingManager",void 0),t([l({readOnly:!0})],X.prototype,"type",void 0),t([l({readOnly:!0})],X.prototype,"updating",null),X=t([h("esri.views.3d.interactive.editingTools.graphicMove3D.GraphicMoveTool")],X);class Y{constructor(t){this.state=null,this.geometryRepresentation=null,this.manipulationXY=null,this.dragging=!1,this.state=new S({graphic:t})}get graphic(){return this.state.graphic}}export{z as GraphicMoveEvent,O as GraphicMoveStartEvent,H as GraphicMoveStopEvent,X as GraphicMoveTool};
