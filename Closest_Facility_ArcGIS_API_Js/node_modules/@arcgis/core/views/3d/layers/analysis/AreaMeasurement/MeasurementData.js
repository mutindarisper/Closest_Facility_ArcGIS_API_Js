/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{deg2rad as e}from"../../../../../core/mathUtils.js";import{unwrapOr as t}from"../../../../../core/maybe.js";import s from"../../../../../core/Quantity.js";import{e as i}from"../../../../../chunks/earcut.js";import{s as o,d as r}from"../../../../../chunks/vec2.js";import{a as n}from"../../../../../chunks/vec2f64.js";import{n as h,i as a,g as d,c as g,o as l,f as p,d as c,a as m,b as _}from"../../../../../chunks/vec3.js";import{c as u}from"../../../../../chunks/vec3f64.js";import{c as f}from"../../../../../chunks/vec4f64.js";import{canProjectWithoutEngine as C,canProjectToWGS84ComparableLonLat as S,projectPointToVector as L,projectPointToWGS84ComparableLonLat as R,projectDirection as P,projectVectorToVector as j}from"../../../../../geometry/projection.js";import{getSphericalPCPF as w,getReferenceEllipsoid as A}from"../../../../../geometry/projectionEllipsoid.js";import W from"../../../../../geometry/SpatialReference.js";import{segmentIntersects as v}from"../../../../../geometry/support/intersectsBase.js";import{segmentLengthGeodesicVector as I,bestFitPlane as U,fitHemisphere as z,triangleAreaEuclidean as G,triangleAreaGeodesic as M,planePointDistance as V,boundingSphere as T}from"../support/measurementUtils.js";import{midpoint as y}from"../support/viewUtils.js";import{getElevationAtPoint as F}from"../../../support/ElevationProvider.js";import{makeOrthonormal as k,tangentFrame as E}from"../../../support/mathUtils.js";class b{constructor(e,t){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.areaCentroidWorldCoords=u(),this.areaCentroidRenderCoords=u(),this.geodesicAreaCentroidRenderCoords=u(),this._length=0,this._centroidRenderCoords=u(),this._planeWorldCoords=f(),this._worldUp=u(),this._worldTangent=u(),this._frame=[u(),u(),u()],this._pathVersion=-1,this._validMeasurement=!1,this._tempU=u(),this._tempV=u(),this._tempVec3=u(),this._tempSphere={center:u(),radius:0},this._sceneView=e,this.unitNormalizer=t}update(e,t,i,o,r){const n=this.unitNormalizer,a=this._sceneView.renderSpatialReference,d=this.unitNormalizer.spatialReference;if(this._pathVersion===e.version&&this._validMeasurement===i&&!r)return!1;this._pathVersion=e.version,this._validMeasurement=i;const g=e.numVertices;this._resize(g);const l=w(t.spatialReference),p=C(t.spatialReference,l)&&S(t.spatialReference),c=this.positionsGeographic,m=this.positionsWorldCoords,_=this.positionsRenderCoords,u=this.positionsSpherical;e.forEachVertexPosition(((e,s)=>{N(t.elevationProvider,e),L(e,m[s],d),L(e,_[s],a),p&&(R(e,c[s]),L(e,u[s],l),h(u[s],u[s]))}));const f=this._updatePathLengths(i);if(this.pathLength=this._length>1?new s(n.normalizeDistance(f),"meters"):null,p){const e=this._updateGeodesicPathLengths(i,d);this.geodesicPathLength=this._length>1?new s(e,"meters"):null}else this.geodesicPathLength=null;return i?(this._updateArea(t,n,a,d,o),p&&this._updateGeodesicArea(t),!0):(this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),!0)}getData(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,unitNormalizer:this.unitNormalizer}}_resize(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push(u()),this.positionsRenderCoords.push(u()),this.positionsProjectedWorldCoords.push(n()),this.positionsFittedRenderCoords.push(u()),this.positionsGeographic.push(u()),this.positionsSpherical.push(u()),this.positionsStereographic.push(n()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(e){const t=this.positionsWorldCoords,s=this.pathSegmentLengths;let i=0;for(let o=0;o<this._length;++o){const r=s[o]=a(t[o],t[(o+1)%this._length]);(o<this._length-1||e)&&(i+=r)}return i}_updateGeodesicPathLengths(e,t){const s=this.positionsGeographic,i=this.geodesicPathSegmentLengths;let o=0;for(let r=0;r<this._length;++r){const n=i[r]=I(s[r],s[(r+1)%this._length],t);(r<this._length-1||e)&&(o+=n)}return o}_updateArea(e,t,i,r,n){const h=e.renderCoordsHelper,a=this.positionsWorldCoords,u=this.positionsRenderCoords,f=this.positionsProjectedWorldCoords,C=this.positionsFittedRenderCoords,S=this._planeWorldCoords,L=this._centroidRenderCoords;y(u,L),h.worldUpAtPosition(L,this._worldUp),h.worldBasisAtPosition(L,0,this._worldTangent),P(L,this._worldUp,i,this._worldUp,r),P(L,this._worldTangent,i,this._worldTangent,r),a.length>2&&U(a,S),this.fittingMode=this._selectFittingMode(S,a,this._worldUp,n);let R=0;if("horizontal"===this.fittingMode){let e=-1/0;u.forEach(((t,s)=>{const i=h.getAltitude(u[s]);i>e&&(e=i,R=s)}))}const w=a[R];let A=S,W=this._worldTangent;"horizontal"===this.fittingMode?A=this._worldUp:"vertical"===this.fittingMode&&(A=this._tempVec3,W=this._worldUp,k(S,this._worldUp,A)),d(this._frame[2],A),k(W,A,this._frame[0]),g(this._frame[1],this._frame[0],this._frame[2]),l(this._frame[1],this._frame[1]);const v=this._tempVec3,I=this._tempU,z=this._tempV;for(let s=0;s<this._length;++s){const e=f[s],t=C[s];p(v,a[s],w),o(e,c(this._frame[0],v),c(this._frame[1],v)),m(I,this._frame[0],e[0]),m(z,this._frame[1],e[1]),_(v,I,z),_(v,v,w),j(v,r,t,i)}this.perimeterLength=this._length>0?new s(t.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,y(C,this.areaCentroidRenderCoords),j(this.areaCentroidRenderCoords,i,this.areaCentroidWorldCoords,r),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?new s(t.normalizeArea(this._computeArea()),"square-meters"):null}_updateGeodesicArea(e){const t=e.renderCoordsHelper,i=this.positionsSpherical,r=this.positionsStereographic,n=this._tempVec3,h=z(i,n);if(!h)return void(this.geodesicArea=null);const a=this._tempU,d=this._tempV;E(n,a,d);for(let s=0;s<this._length;++s){const e=c(i[s],a),t=c(i[s],d),h=c(i[s],n);o(r[s],e/h,t/h)}m(n,n,A(e.spatialReference).radius),t.toRenderCoords(n,w(e.spatialReference),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=h&&0===this.geodesicIntersectingSegments.size?new s(this._computeGeodesicArea(),"square-meters"):null}_updatePerimeterLengths(){const e=this.positionsProjectedWorldCoords,t=this.perimeterSegmentLengths;let s=0;for(let i=0;i<this._length;++i){s+=t[i]=r(e[i],e[(i+1)%this._length])}return s}_updateIntersectingSegments(){const e=this.positionsProjectedWorldCoords,t=this.intersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],r=e[(s+1)%this._length],n=e[i],h=e[(i+1)%this._length];v(o,r,n,h)&&(t.add(s),t.add(i))}}_computeArea(){const e=this.positionsProjectedWorldCoords,t=x(e,2),s=this.triangleIndices=new Uint32Array(i(t,[],2));let o=0;for(let i=0;i<s.length;i+=3)o+=G(e[s[i]],e[s[i+1]],e[s[i+2]]);return o}_updateGeodesicIntersectingSegments(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],r=e[(s+1)%this._length],n=e[i],h=e[(i+1)%this._length];v(o,r,n,h)&&(t.add(s),t.add(i))}}_computeGeodesicArea(){const e=this.positionsGeographic,t=x(this.positionsStereographic,2),s=this.geodesicTriangleIndices=new Uint32Array(i(t,[],2));let o=0;for(let i=0;i<s.length;i+=3)o+=M(e[s[i]],e[s[i+1]],e[s[i+2]],W.WGS84);return o}_selectFittingMode(t,s,i,o){const r=s.map((e=>Math.abs(V(t,e)))).reduce(((e,t)=>Math.max(e,t)),0);T(s,this._tempSphere);const n=r/(2*this._tempSphere.radius),h=n<o.maxRelativeErrorCoplanar,a=n<o.maxRelativeErrorAlmostCoplanar;let d="horizontal";if(h)d="oblique";else if(a){d=Math.abs(c(i,t))>Math.cos(e(o.verticalAngleThreshold))?"horizontal":"vertical"}return d}}function x(e,t){const s=new Float64Array(e.length*t);for(let i=0;i<e.length;++i){const o=e[i];for(let e=0;e<t;++e)s[i*t+e]=o[e]}return s}function N(e,s){s.hasZ||(s.z=t(F(e,s,"ground"),0))}export{b as MeasurementDataManager};
