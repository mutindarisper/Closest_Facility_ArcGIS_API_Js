/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import"../../../../../geometry.js";import t from"../../../../../core/Accessor.js";import s from"../../../../../core/Evented.js";import r from"../../../../../core/Handles.js";import{handlesGroup as n,makeHandle as i}from"../../../../../core/handleUtils.js";import{isSome as o,isNone as a,unwrapOr as l,abortMaybe as c,removeMaybe as h,none as p}from"../../../../../core/maybe.js";import{createTask as g,ignoreAbortErrors as u}from"../../../../../core/promiseUtils.js";import{property as d}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/Logger.js";import{subclass as y}from"../../../../../core/accessorSupport/decorators/subclass.js";import{reactionInit as m,reaction as _}from"../../../../../core/accessorSupport/trackingUtils.js";import{g as v,f,n as A,a as b,b as T,j as C,w as O}from"../../../../../chunks/vec3.js";import{a as E,c as w}from"../../../../../chunks/vec3f64.js";import{projectBoundingRect as j}from"../../../../../geometry/projection.js";import{containsPointObject as I,empty as S}from"../../../../../geometry/support/aaBoundingRect.js";import{fromPoints as L,create as P}from"../../../../../geometry/support/ray.js";import{LineOfSightAnalysis as R}from"./LineOfSightAnalysis.js";import{LineOfSightRayIntersector as V}from"./LineOfSightRayIntersector.js";import{LineOfSightResult as D}from"./LineOfSightResult.js";import{getElevationAtPoint as H}from"../../../support/ElevationProvider.js";import{toGraphic as x}from"../../../webgl-engine/lib/intersectorUtilsConversions.js";import{ImmediateTask as N,TaskPriority as k}from"../../../../support/Scheduler.js";import F from"../../../../../geometry/Point.js";let z=class extends(s.EventedMixin(t)){constructor(e){super(e),this._tasks=N,this._handles=new r,this._analysisHandles=new r}initialize(){var e;const t=null==(e=this.view.resourceController)?void 0:e.scheduler;t&&(this._tasks=t.registerTask(k.LINE_OF_SIGHT_TOOL));this._handles.add([this._connectObserver(),this._connectAnalyses(),this._connectTargets()]),this._intersector=new V({view:this.view})}destroy(){this._handles.destroy(),this._analysisHandles.destroy(),this._analyses.removeAll()}get updating(){return this._tasks.updating}get priority(){return this._tasks.priority}set priority(e){this._tasks.priority=e}get _analyses(){return this.layerViewData.analyses}get _observerEngineLocation(){return this.layerViewData.observerEngineLocation}set _observerEngineLocation(e){this.layerViewData.observerEngineLocation=e}get _screenPixelSize(){return this.view.state.camera.computeScreenPixelSizeAt(this._observerEngineLocation)}getLineOfSightComputationDependencies(e){const{inputPoints:t}=e;return{inputPoints:t}}computeAnalysis(e){const{analysis:t}=e,{inputPoints:s,computationResult:r}=t,{observerAdjusted:n,targetAdjusted:i}=s,{start:o,end:a}=r;v(o,n),v(a,i);this._canComputeAnalysis(t)?this._computeAnalysisIntersection(e):this._interpolateAnalysisIntersection(e),t.updateComputationResults(),this.emit("result-changed",{target:e.analysis.target,result:t.result})}_adjustStartEndPositions(e){const t=this._screenPixelSize,s=this.view,{inputPoints:r}=e,{observer:n,observerSurfaceNormal:i,target:a,targetSurfaceNormal:l,observerAdjusted:c,targetAdjusted:h}=r,p=U;o(i)?v(p,i):f(p,a,n);const g=t;A(p,p),b(p,p,Math.min(g,1)),T(c,n,p),o(l)?v(p,l):f(p,n,a);const u=s.state.camera.computeScreenPixelSizeAt(a);A(p,p),b(p,p,Math.min(u,1)),T(h,a,p)}_computeAnalysisIntersection({analysis:e,interpolationInfo:t}){const{view:s}=this,{sceneIntersectionHelper:r,renderCoordsHelper:n}=s;if(a(r))return;const i=this._intersector.intersector,{computationResult:l,inputPoints:c}=e,{observer:h,target:p}=c,{start:g,end:u}=l,d=L(g,u,B);r.intersectToolIntersectorRay(d,i);const y=l.intersection,m=U,_=!!i.results.min&&i.results.min.getIntersectionPoint(y);let f=!0;if(_){v(t.originalIntersection,y),v(t.originalObserver,g),v(t.originalTarget,u),n.fromRenderCoords(y,m,s.spatialReference);const e=1-C(u,p)/C(g,p);f=C(h,y)>=e*C(h,p)}const A=new F(m,s.spatialReference);{const{result:t,target:r}=e;o(t)?(t.target=r,t.intersectedGraphic=f?null:x(i.results.min,s),t.intersectedLocation=f?null:A,t.visible=!!_&&f):e.result=new D({target:r,elevationAlignedTargetLocation:e.elevationAlignedTargetLocation,intersectedGraphic:f?null:x(i.results.min,s),intersectedLocation:f?null:A,visible:!!_&&f})}l.isValid=c.isValid=!0,l.isTargetVisible=f}_interpolateAnalysisIntersection({analysis:e,interpolationInfo:t}){const{computationResult:s,inputPoints:r}=e,{start:n,end:i,intersection:o}=s,{originalIntersection:a,originalObserver:l,originalTarget:c}=t;if(v(o,a),r.isValid){const e=U,t=C(l,a)/C(l,c);O(e,n,l),b(e,e,1-t),T(o,o,e),O(e,i,c),b(e,e,t),T(o,o,e),s.isValid=!0}else e.result=new D,s.isValid=!1,s.isTargetVisible=!1}_canComputeAnalysis(e){const t=this.layerViewData.elevationAlignedObserver,s=this.view.frustum;if(a(t)||a(e.target)||a(s))return!1;const{observerAdjusted:r,targetAdjusted:n}=e.inputPoints,i=s.intersectsPoint(r),o=s.intersectsPoint(n);return i&&o}_onObserverChange(e){if(a(e))return this.layer.targets.removeAll(),void(this.layerViewData.elevationAlignedObserver=null);this.layerViewData.elevationAlignedObserver=this._applyElevationAlignment(e,this.layer.intersection);const t=w();this.view.renderCoordsHelper.toRenderCoords(this.layerViewData.elevationAlignedObserver,t),this._observerEngineLocation=t,this.priority=k.LINE_OF_SIGHT_TOOL_INTERACTIVE}_applyElevationAlignment(e,t){if(e.hasZ&&(a(t)||"Graphic"===t.type))return e;const s=e.clone();return s.z=l(H(this.view.elevationProvider,s),0),s}_onObserverChangeForAnalysis(e){e.inputPoints.isValid=!1}_onObserverEngineForAnalysis(e,t,s){const{inputPoints:r}=e;if(v(r.observer,t),o(s)){const e=this._intersector.updateFromIntersectionResult(s);o(e)&&this.view.renderCoordsHelper.toRenderCoords(e,r.observer),r.observerSurfaceNormal=E(s.normal)}else r.observerSurfaceNormal=null;this._adjustStartEndPositions(e),e.updateInputPoints(),this.priority=k.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onTargetLocationChange(e,t,s){const{inputPoints:r}=e;if(r.isValid=!1,o(t)){if(e.elevationAlignedTargetLocation=this._applyElevationAlignment(t,s),this.view.renderCoordsHelper.toRenderCoords(e.elevationAlignedTargetLocation,r.target),o(s)){const e=this._intersector.updateFromIntersectionResult(s);o(e)&&this.view.renderCoordsHelper.toRenderCoords(e,r.target),r.targetSurfaceNormal=E(s.normal)}else r.targetSurfaceNormal=null;this._adjustStartEndPositions(e),e.updateInputPoints()}this.priority=k.LINE_OF_SIGHT_TOOL_INTERACTIVE}_connectAnalysisToTarget(e){return m((()=>({analysis:e,targetLocation:e.target.location,targetIntersection:e.target.intersection})),(({analysis:e,targetLocation:t,targetIntersection:s})=>{o(t)&&this._onTargetLocationChange(e,t,s)}))}_connectAnalysisToObserver(e){return m((()=>({analysis:e,observer:this.layerViewData.elevationAlignedObserver})),(({analysis:e})=>{this._onObserverChangeForAnalysis(e)}))}_connectAnalysisToObserverEngine(e){return m((()=>({analysis:e,observer:this._observerEngineLocation,observerIntersection:this.layer.intersection})),(({analysis:e,observer:t,observerIntersection:s})=>{this._onObserverEngineForAnalysis(e,t,s)}))}_connectAnalysisToCamera(e){return _((()=>({camera:this.view.state.camera,isDirty:this._isCameraDirty})),(({isDirty:t})=>{e.inputPoints.isValid&&!t||e.updateInputPoints()}))}_connectAnalysisToElevation(e){return this.view.elevationProvider.on("elevation-change",(t=>{if(!this._canComputeAnalysis(e))return;const s=this.layer.observer;G(t.extent,t.spatialReference,s)&&this._onObserverChange(s);const r=e.target;o(r)&&G(t.extent,t.spatialReference,r.location)&&e.onElevationChange()}))}_connectAnalysisForCompute(e){let t=p;const s={analysis:e,interpolationInfo:{originalIntersection:w(),originalObserver:w(),originalTarget:w()}};return n([m((()=>this.getLineOfSightComputationDependencies(e)),(()=>{t=c(t),t=g((async e=>{await u(this._tasks.schedule((()=>this.computeAnalysis(s)),e))}))})),i((()=>t=c(t)))])}_connectAnalysis(e){const t=this._analysisHandles;t.has(e)||t.add([this._connectAnalysisToTarget(e),this._connectAnalysisToObserver(e),this._connectAnalysisToObserverEngine(e),this._connectAnalysisToCamera(e),this._connectAnalysisToElevation(e),this._connectAnalysisForCompute(e)])}_disconnectAnalysis(e){this._analysisHandles.remove(e)}_onAnalysesCollectionChange(e){e.added.forEach((e=>this._connectAnalysis(e))),e.removed.forEach((e=>this._disconnectAnalysis(e)))}_onTargetsChange(e){return this._analyses.removeAll(),e.items.length>0&&e.forEach((e=>this._addTarget(e))),e.on("change",(e=>this._onTargetCollectionChange(e)))}_onTargetCollectionChange(e){e.added.forEach((e=>this._addTarget(e))),e.removed.forEach((e=>this._removeTarget(e)))}_onCursorTargetChange(e,t){o(t)&&this._removeTarget(t),o(e)&&this._addTarget(e)}_addTarget(e){const t=this._analyses;t.some((t=>t.target===e))||t.add(new R({target:e}))}_removeTarget(e){const t=this._analyses,s=t.find((t=>t.target===e));t.remove(s)}_connectObserver(){return n([m((()=>this.layer.observer),(e=>this._onObserverChange(e)))])}_connectAnalyses(){let e=null;return n([m((()=>this._analyses),(t=>{e=h(e),e=t.on("change",(e=>this._onAnalysesCollectionChange(e))),t.forEach((e=>this._connectAnalysis(e)))})),i((()=>e=h(e)))])}_connectTargets(){let e=null;return n([m((()=>this.layer.targets),(t=>{e=h(e),e=this._onTargetsChange(t)})),m((()=>this.layerViewData.cursorTarget),((e,t)=>{this._onCursorTargetChange(e,t)})),i((()=>{e=h(e)}))])}get _isCameraDirty(){const e=this.layerViewData.elevationAlignedObserver,{view:t}=this,{renderCoordsHelper:s}=t;if(a(e)||a(s))return!1;const r=U;s.toRenderCoords(e,r);const n=t.state.camera.computeScreenPixelSizeAt(r);return Math.abs((n-this._screenPixelSize)/this._screenPixelSize)>M}};function G(e,t,s){return!a(s)&&(j(e,t,Z,s.spatialReference),I(Z,s))}e([d({constructOnly:!0})],z.prototype,"layer",void 0),e([d({constructOnly:!0})],z.prototype,"layerViewData",void 0),e([d({constructOnly:!0})],z.prototype,"view",void 0),e([d()],z.prototype,"updating",null),e([d()],z.prototype,"priority",null),e([d()],z.prototype,"_analyses",null),e([d()],z.prototype,"_observerEngineLocation",null),e([d()],z.prototype,"_screenPixelSize",null),e([d()],z.prototype,"_tasks",void 0),e([d()],z.prototype,"_isCameraDirty",null),z=e([y("esri.views.3d.layers.analysis.LineOfSight.LineOfSightController")],z);const M=.1,U=w(),B=P(),Z=S();export{z as LineOfSightController};
