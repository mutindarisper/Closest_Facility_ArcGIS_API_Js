/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{sign as t,acosClamped as i,reciprocalClamped as r}from"../../../../core/mathUtils.js";import{isSome as s,get as a}from"../../../../core/maybe.js";import{s as o}from"../../../../chunks/mat2.js";import{s as n,b as l}from"../../../../chunks/vec2.js";import{f as h}from"../../../../chunks/vec2f64.js";import{s as c,b as p,d as m,c as d,a as f,n as u,o as y,f as g}from"../../../../chunks/vec3.js";import{c as _}from"../../../../chunks/vec3f32.js";import{d as b,c as v}from"../../../../chunks/vec3f64.js";import{projectBuffer as x}from"../../../../geometry/projection.js";import{create as w,empty as S,expandWithBuffer as D,intersectsClippingArea as R}from"../../../../geometry/support/aaBoundingBox.js";import{makeDehydratedPoint as P}from"../../../../layers/graphics/dehydratedFeatures.js";import{needsElevationUpdates3D as V,evaluateElevationAlignmentAtPoint as j}from"./elevationAlignmentUtils.js";import{ElevationContext as C}from"./ElevationContext.js";import{Graphics3DObject3DGraphicLayer as A}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as E,getAttributeValue as L}from"./Graphics3DSymbolLayer.js";import{isValidSize as z}from"./graphicUtils.js";import{initFastSymbolUpdatesState as U,updateFastSymbolUpdatesState as k}from"../support/FastSymbolUpdates.js";import{Object3D as F}from"../../webgl-engine/lib/Object3D.js";import{PathGeometry as G,isPathGeometry as I}from"../../webgl-engine/lib/PathGeometry.js";import{Profile as M,SimpleExtruder as O,MiterExtruder as B,RoundCapBuilder as q,TriangulationCapBuilder as H,NoCapBuilder as T,PathVertex as N,Path as W,Builder as Z,FastUpdatePathGeometry as J,StaticPathGeometry as K,computeMinimumRotationTangentFrame as Q,vertexSpaceToProfileSpace as X}from"../../webgl-engine/lib/pathGeometryUtils.js";import{DefaultMaterial as Y}from"../../webgl-engine/materials/DefaultMaterial.js";import{PathMaterial as $}from"../../webgl-engine/materials/PathMaterial.js";const ee=["polyline"];class te extends E{constructor(e,t,i,r){super(e,t,i,r),this._intrinsicSize=h(1,1),this.upVectorAlignment="path",this.stencilWidth=.1,this.ensureDrapedStatus(!1)}async doLoad(){const t=s(this.symbolLayer.width)?this.symbolLayer.width:this.symbolLayer.height,i=s(this.symbolLayer.height)?this.symbolLayer.height:t;this._vvConvertOptions={modelSize:[1,1,1],symbolSize:[t,1,i],unitInMeters:this._context.renderCoordsHelper.unitInMeters,transformation:{anchor:[0,0,0],scale:[1,1,1],rotation:[0,0,0]},supportedTypes:{size:!0,color:!0,opacity:!0,rotation:!1}},this._context.renderer&&this._context.renderer.visualVariables&&this._context.renderer.visualVariables.length>0?this._fastUpdates=U(this._context.renderer,this._vvConvertOptions):this._fastUpdates={enabled:!1};const r=this.symbolLayer.anchor||"center";this.upVectorAlignment="path","heading"===this.symbolLayer.profileRotation&&(this.upVectorAlignment="world");const o=this.symbolLayer.profile||"circle";if("quad"===o)this._profile=M.rect();else this._profile=M.circle(de);let h=[0,0];"center"!==r&&(h={left:[.5,0],right:[-.5,0],top:[0,-.5],bottom:[0,.5]}[r],this._profile.translate(h[0],h[1]));switch(this.symbolLayer.join||"simple"){case"round":this._extruder=new B(0,pe);break;case"bevel":this._extruder=new B(0,1);break;case"miter":this._extruder=new B(.8*Math.PI,1);break;default:this._extruder=new O}const c=this.symbolLayer.cap||"butt";switch(c){case"none":this._startCap=new T,this._endCap=new T;break;default:this._startCap=new H(this._profile,0),this._endCap=new H(this._profile,0,!0);break;case"square":this._startCap=new H(this._profile,-.5),this._endCap=new H(this._profile,.5,!0);break;case"round":{const e="quad"===o;this._startCap=new q({profile:this._profile,flip:!1,breakNormals:e,subdivisions:me}),this._endCap=new q({profile:this._profile,flip:!0,breakNormals:e,subdivisions:me});break}}const p=a(this.symbolLayer,"material","color"),m=this._getCombinedOpacityAndColor(p),d=b(m),f=m[3],u=f<1||this.needsDrivenTransparentPass,y={diffuse:d,ambient:d,opacity:f,transparent:u,vertexColors:!1,slicePlaneEnabled:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,cullFace:u||"none"===c?0:2,offsetTransparentBackfaces:!0};if(!this._drivenProperties.size&&(n(this._intrinsicSize,t,i),!z(this._intrinsicSize[0])||!z(this._intrinsicSize[1])))throw new e("graphics3dpathsymbollayer:invalid-size","Symbol sizes may not be negative values");this._fastUpdates.enabled&&this._fastUpdates.visualVariables.size||l(this._intrinsicSize,this._intrinsicSize,1/this._context.renderCoordsHelper.unitInMeters),this._fastUpdates.enabled?(Object.assign(y,this._fastUpdates.materialParameters,{size:[this._intrinsicSize[0],this._intrinsicSize[1],0]}),this._material=new $(y)):(y.vertexColors=this._drivenProperties.color||this._drivenProperties.opacity,this._material=new Y(y)),this._material.setParameterValues({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._context.stage.add(this._material)}destroy(){super.destroy(),this._context.stage.remove(this._material),this._material=null}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,ee,this.symbolLayer.type))return null;const i=this.setGraphicElevationContext(t,new C),r=e.renderingInfo;return this._createAs3DShape(t,r,i,t.uid)}layerOpacityChanged(){const e=a(this.symbolLayer,"material","color"),t=this._getCombinedOpacity(e),i=t<1||this.needsDrivenTransparentPass;return this._material.setParameterValues({opacity:t,transparent:i}),!0}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,V)}slicePlaneEnabledChanged(){return this._material.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled}),!0}physicalBasedRenderingChanged(){return this._material.setParameterValues({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0}pixelRatioChanged(){return!0}applyRendererDiff(e,t){for(const i in e.diff){if("visualVariables"!==i)return!1;if(!k(this._fastUpdates,t,this._vvConvertOptions))return!1;this._material.setParameterValues(this._fastUpdates.materialParameters)}return!0}getVertexData(e){let t=0;const i=e.paths,r=[],s=e.spatialReference,a=this._context.elevationProvider.spatialReference,o=this._context.renderCoordsHelper.spatialReference;for(const m of i)t+=m.length;const n=new Float64Array(3*t),l=new Float64Array(3*t),h=new Float64Array(3*t);let c=0;for(const m of i){r.push({index:c,numVertices:m.length});for(const t of m)n[c++]=t[0],n[c++]=t[1],n[c++]=e.hasZ?t[2]:0}let p=!0;return s.equals(a)?this._copyVertices(n,0,l,0,t):p=x(n,s,0,l,a,0,t),a.equals(o)?this._copyVertices(l,0,h,0,t):x(l,a,0,h,o,0,t),{pathVertexDataInfos:r,vertexDataGS:n,vertexDataES:l,vertexDataRS:h,projectionSuccess:p,terrainElevation:0}}_copyVertices(e,t,i,r,s){t*=3,r*=3;for(let a=0;a<s;++a)i[r++]=e[t++],i[r++]=e[t++],i[r++]=e[t++]}_createAs3DShape(e,t,i,r){const a=e.geometry,o=new Array,n=new Array,l=new Array,h=a.spatialReference,p=w(),m=this._context.renderCoordsHelper;ne.spatialReference=h;const d=this.getVertexData(a);if(!d.projectionSuccess)return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"),null;if(d.pathVertexDataInfos.length>0){for(let r=0;r<d.pathVertexDataInfos.length;++r){const a=d.pathVertexDataInfos[r],f=a.index,u=a.numVertices;if(u<2)continue;if(s(this._context.clippingExtent)&&(S(p),D(p,d.vertexDataES,3*f,u),!R(p,this._context.clippingExtent)))continue;const y=[];for(let e=f;e<f+3*u;){const t=e++,r=e++,s=e++,a=new N;c(a.posGS,d.vertexDataGS[t],d.vertexDataGS[r],d.vertexDataGS[s]),c(a.posES,d.vertexDataES[t],d.vertexDataES[r],d.vertexDataES[s]);const o=j(a.posES,this._context.elevationProvider,i,m,null);c(le,d.vertexDataRS[t],d.vertexDataRS[r],d.vertexDataRS[s]),m.setAltitude(le,o),c(a.pos,le[0],le[1],le[2]),y.push(a)}const g=new W(y);ie(g,this.upVectorAlignment,this._context.renderCoordsHelper);const _=new Z(g,this._profile,this._extruder,this._startCap,this._endCap);let b=null;if(this._fastUpdates.enabled){const t=this._fastUpdates.visualVariables,i=t.size?L(t.size.field,e):0,r=t.color?L(t.color.field,e):0,s=t.opacity?L(t.opacity.field,e):0;b=new J(_,i,r,s)}else{const e=[this._intrinsicSize[0],this._intrinsicSize[1]];this._drivenProperties.size&&(e[0]*=re(t.size[0],"symbol-value"===t.size[2]?this.symbolLayer.height||0:t.size[2],this.symbolLayer.width||0),e[1]*=re(t.size[2],"symbol-value"===t.size[0]?this.symbolLayer.width||0:t.size[0],this.symbolLayer.height||0));let i=null;this._drivenProperties.color&&(i=t.color),this._drivenProperties.opacity&&null!=t.opacity&&(i=i?[i[0],i[1],i[2],t.opacity]:[1,1,1,t.opacity]);const r=new K(_);r.bake(e),i&&r.bakeVertexColors(i),b=r}const{vertexAttributes:v,indices:x}=b.createGeometryData(),w=new G(v,x,b,h,this.upVectorAlignment,this.stencilWidth);o.push(w),n.push(this._material),l.push(b.xform)}if(o.length>0){const e={layerUid:this._context.layer.uid,graphicUid:r},t=new F({geometries:o,materials:n,transformations:l,metadata:e}),s=new A(this,t,o,null,null,ae,i);return s.alignedSampledElevation=d.terrainElevation,s.needsElevationUpdates=V(i.mode),s}}else 0!==a.paths.length&&a.paths.some((e=>e.length>0))||this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)");return null}}function ie(e,s,a){switch(s){case"world":for(const t of e.vertices)p(he,t.pos,e.offset),a.worldUpAtPosition(he,le),t.setFrameFromUpVector(le),t.computeRotationAxisAndAngleFromUpVector();break;case"path":p(he,e.vertices[0].pos,e.offset),a.worldUpAtPosition(he,le),Q(e,le);for(const s of e.vertices){const e=t(m(s.frame.right,s.vRight));d(s.rotationFrame.up,s.vRight,s.vLeft),f(s.rotationFrame.up,s.rotationFrame.up,e),u(s.rotationFrame.up,s.rotationFrame.up);const a=m(s.rotationFrame.up,s.frame.up),n=m(s.rotationFrame.up,s.frame.right);if(f(he,s.frame.up,-n),f(ce,s.frame.right,a),p(he,he,ce),u(s.rotationFrame.right,he),X(s.rotationRight,s.frame,s.rotationFrame.right),y(he,s.vLeft),s.rotationAngle=-e*(Math.PI-i(m(he,s.vRight))),Math.abs(s.rotationAngle)>0){const e=r(Math.cos(.5*s.rotationAngle));o(s.miterStretch,1+(e-1)*s.rotationRight[0]*s.rotationRight[0],(e-1)*s.rotationRight[0]*s.rotationRight[1],(e-1)*s.rotationRight[0]*s.rotationRight[1],1+(e-1)*s.rotationRight[1]*s.rotationRight[1])}const l=Math.PI-s.rotationAngle;s.maxStretchDistance=Math.abs(Math.min(s.vLeftLength,s.vRightLength)*r(Math.cos(.5*l)))}}}function re(e,t,i){switch(e){case"symbol-value":return i;case"proportional":return t;default:return e}}function se(e,t,i,r){let s=0;for(const a of e.vertices){const o=j(a.posES,i,t,r,fe);s+=fe.sampledElevation,p(le,a.pos,e.offset),r.setAltitude(le,o),g(a.pos,le,e.offset)}return e.updatePathVertexInformation(),s/e.vertices.length}function ae(e,t,i,r){const s=e.stageObject,a=s.geometryRecords,o=a.length;let n=0;oe.spatialReference=r.spatialReference;for(let l=0;l<o;l++){const e=a[l].geometry;if(!I(e))continue;const o=e.path,h=o.builder.path,c=e.geometrySR;ne.spatialReference=c,n+=se(h,t,i,r),"world"!==e.upVectorAlignment&&ie(h,e.upVectorAlignment,r),o.onPathChanged(),e.invalidateBoundingInfo(),s.geometryVertexAttrsUpdated(l)}return n/o}const oe=P(0,0,0,null),ne=P(0,0,0,null),le=v(),he=_(),ce=_(),pe=3,me=3,de=10,fe={verticalDistanceToGround:0,sampledElevation:0};export{te as Graphics3DPathSymbolLayer,de as NUM_CIRCLE_PROFILE_SUBDIVISIONS,me as NUM_ROUND_CAP_EXTRUSION_SUBDIVISIONS,pe as NUM_ROUND_JOIN_SUBDIVISIONS,te as default};
