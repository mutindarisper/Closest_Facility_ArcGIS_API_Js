/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import e from"../../../Camera.js";import t from"../../../core/Logger.js";import{deg2rad as n,rad2deg as r}from"../../../core/mathUtils.js";import{isNone as i,unwrapOr as o,isSome as a}from"../../../core/maybe.js";import{createResolver as s}from"../../../core/promiseUtils.js";import{a as l,b as c,j as f,i as u,g as m}from"../../../chunks/vec3.js";import{a as p,c as d}from"../../../chunks/vec3f64.js";import v from"../../../geometry/Point.js";import{projectPointToVector as h,projectVectorToVector as g,projectVectorToPoint as y,project as R}from"../../../geometry/projection.js";import{getReferenceEllipsoid as x}from"../../../geometry/projectionEllipsoid.js";import M from"../../../geometry/SpatialReference.js";import{getResolutionForScale as j}from"../../../geometry/support/scaleUtils.js";import{cameraOnContentAlongViewDirection as w}from"../camera/intersectionUtils.js";import{c as S,t as T}from"../../../chunks/cameraUtilsPlanar.js";import{c as z,t as C}from"../../../chunks/cameraUtilsSpherical.js";import{getGreatCircleSpanAt as b}from"./earthUtils.js";import{getElevationAtPoint as U}from"./ElevationProvider.js";import{Cyclical as H}from"./mathUtils.js";import{isSpatialReferenceSupported as P}from"../../support/spatialReferenceSupport.js";const k=t.getLogger("esri.views.3d.support.cameraUtils"),A=39.37,I=96,L=1,q=8,E=5,F=1,G=d(),O=d(),W={heading:0,tilt:0},X=new v,D=new H(-20037508.342788905,20037508.342788905),Y=new H(-180,180);function N(e){return e.spatialReference||M.WGS84}function Z(e){return"global"===e.viewingMode?z:S}function B(e,t,n,r,i){return Z(e).headingTiltToDirectionUp(t,n,r,i)}function J(e,t){if(i(t))return null;const r=e.renderSpatialReference,o=Z(e).headingTiltToDirectionUp,a=d();if(!h(t.position,a,r))return null;const s=o(a,t.heading,t.tilt);l(s.direction,s.direction,e.state.camera.distance),c(s.direction,s.direction,a);const f=w(e,a,s.direction,s.up);return f.fov=n(t.fov),f}const K=d();function Q(t,n,o){const a=t.renderSpatialReference,s=te(t,n.eye,n.viewForward,n.up,W);let l=N(t);return g(n.eye,a,K,l)||(l=M.WGS84,g(n.eye,a,K,l)),i(o)?new e(new v(K,l),s.heading,s.tilt,r(n.fov)):(o.position.x=K[0],o.position.y=K[1],o.position.z=K[2],o.position.spatialReference=l,o.heading=s.heading,o.tilt=s.tilt,o.fov=r(n.fov),o)}function V(e,t,r){const i=e.state.camera,o=i.width/2/i.pixelRatio;1===e.renderCoordsHelper.viewingMode&&null!=r&&(t*=Math.cos(n(r))),t/=e.renderCoordsHelper.unitInMeters;return o/(I*A/t)/Math.tan(i.fovX/2)}function $(e,t,r){const i=e.state.camera,o=t*Math.tan(i.fovX/2),a=i.width/2/i.pixelRatio;let s=I*A/(a/o);return 1===e.renderCoordsHelper.viewingMode&&(s/=Math.cos(n(r))),s*=e.renderCoordsHelper.unitInMeters,s}function _(e,t,n,r,i,o){return ee(e,t,V(e,n,t.latitude),r,i,o)}function ee(e,t,n,r,o,a){if(we(a)){const s=new je(a.signal);return ae(e,r.heading,r.tilt,t,n,o,s),void s.resolver.promise.then((t=>{const n=ge(e,t,r.fov);if(!i(n))return a.resolver.resolve(n);a.resolver.reject()}),(e=>a.resolver.reject(e)))}const s=ae(e,r.heading,r.tilt,t,n,o);return ge(e,s,r.fov,a)}function te(e,t,n,r,i){return Z(e).directionToHeadingTilt(t,n,r,i)}function ne(e,t){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(t,X,e.spatialReference)&&o(U(e.elevationProvider,X),0)>X.z-F)}async function re(e,t,n){if(!e.renderCoordsHelper.fromRenderCoords(t,X,e.spatialReference))return!1;const r=await e.elevationProvider.queryElevation(X.x,X.y,X.z,X.spatialReference,"ground",n);return o(r,0)>X.z-F}async function ie(e,t,n){const r=d();if(t)if(t instanceof v){if(h(t,r,e.renderSpatialReference),null==t.z&&null!=e.basemapTerrain){const i=await e.elevationProvider.queryElevation(t.x,t.y,t.z,t.spatialReference,"ground",n);return a(i)&&e.renderCoordsHelper.setAltitude(r,i),r}}else m(r,t);else m(r,e.state.camera.center);return r}function oe(e,t){const n=d();if(t&&t instanceof v){if(h(t,n,e.renderSpatialReference),null==t.z&&null!=e.basemapTerrain){const r=U(e.elevationProvider,t);a(r)&&e.renderCoordsHelper.setAltitude(n,r)}}else m(n,t||e.state.camera.center);return n}function ae(e,t,n,r,i,o,a){const s=r&&r instanceof v?r:null;if(we(a))return ie(e,r,a.signal).then((r=>{se(e,t,n,s,r,i,o,a)}),(e=>a.resolver.reject(e))),null;const l=oe(e,r);return se(e,t,n,s,l,i,o,a)}function se(e,t,n,r,o,a,s,l){if(i(r)){const t=e.renderSpatialReference;if(r=y(o,t,N(e)),i(r))return null}a=Math.max(a,e.state.constraints.minimumPoiDistance);const c=ue(e,t,n,o,a,s),f=(0,Z(e).eyeForCenterWithHeadingTilt)(o,a,c.heading,c.tilt);if(1===s&&"global"===e.viewingMode&&n>0){const i=()=>{const i=ve(e,o,a,de(e,a,n,o));return se(e,t,i,r,o,a,s=n-i<1?0:1,l)},c=e.map.ground.navigationConstraint;if(!c||"stay-above"===c.type){if(ne(e,f.eye))return i();if(we(l))return re(e,f.eye,l.signal).then((e=>e?i():(l.resolver.resolve({eye:f.eye,up:f.up,center:p(o),heading:f.heading,tilt:f.tilt}),null))),null}}const u=!l||we(l)?{center:d(),eye:d(),up:d(),tilt:0,heading:0}:l;return u.eye=f.eye,u.up=f.up,u.center=p(o),u.heading=f.heading,u.tilt=f.tilt,we(l)&&l.resolver.resolve(u),u}function le(e,t,n,r,a,s=null){const l=null!=t.zmax&&null!=t.zmin;let c,f,u;if("global"===e.viewingMode){if(!P(t.spatialReference,"global"))return we(s)&&s.resolver.reject(),null;const e=new v(t.xmin,t.ymin,t.spatialReference),n=new v(t.xmax,t.ymax,t.spatialReference),r=t.spatialReference.isGeographic?Y:D;c=new v({x:r.center(e.x,n.x),y:(n.y+e.y)/2,z:l?(t.zmax+t.zmin)/2:null,spatialReference:t.spatialReference});const i=x(t.spatialReference),o=b(c,e,n);f=o.lon,u=o.lat,r.diff(e.x,n.x)>r.range/2&&(f+=i.halfCircumference),f=Math.min(f,i.halfCircumference),u=Math.min(u,i.halfCircumference)}else{const n=o(e.renderSpatialReference,t.spatialReference);n.equals(t.spatialReference)||(t=R(t,n)),f=t.xmax-t.xmin,u=t.ymax-t.ymin;const r=l?(t.zmax+t.zmin)/2:null;c=new v({x:t.xmin+.5*f,y:t.ymin+.5*u,z:r,spatialReference:n})}const m=l?t.zmax-t.zmin:0,p=e.state.camera,d=1/Math.tan(p.fovX/2),h=1/Math.tan(p.fovY/2),g=1/Math.tan(p.fov/2),y=Math.max(.5*f*d,.5*u*h,.5*m*g)/L;if(we(s)){const t=new je(s.signal);return ae(e,n,r,c,y,a,t),void t.resolver.promise.then((t=>{const n=ge(e,t,e.camera.fov);if(!i(n))return s.resolver.resolve(n);s.resolver.reject()}),(e=>s.resolver.reject(e)))}const M=ae(e,n,r,c,y,a);return ge(e,M,e.camera.fov,s)}function ce(e,t,n){const r=e.renderSpatialReference,o=y(n,r,N(e));if(i(o))return null;const a=Math.tan(t.fovX/2),s=Math.tan(t.fovY/2),l=f(t.eye,n),c=2*l*a*L,u=2*l*s*L;return"global"===e.viewingMode?C(e,o,c,u):T(e,o,c,u)}function fe(e,t,n){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(n/r)/Math.LN2>q)return!0;const o=e.renderSpatialReference,a=N(e),s=y(t,o,a),l=y(e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation,o,a);if(i(s)||i(l))return!1;const c=Math.tan(.5*e.state.camera.fov)*r;return l.distance(s)/c>E}function ue(e,t,n,r,i,o){let a=0;return 1===o&&fe(e,r,i)?(t=0,a=pe(e,i,n,r)):a=he(e,r,i,n),a=e.state.constraints.clampTilt(i,a),{heading:t,tilt:n=ve(e,r,i,a)}}const me=.7;function pe(e,t,n,r){const i=e.state.constraints.tilt(t);i.max=Math.min(i.max,.5*Math.PI);const o=i.min*(1-me)+i.max*me,a=he(e,r,t,n);return Math.min(a,o)}function de(e,t,n,r){const i=e.state.constraints.tilt(t);let o=he(e,r,t,n);return o=Math.min(o,.5*Math.PI),i.min*(1-me)+o*me}function ve(e,t,n,r){return Z(e).lookAtTiltToEyeTilt(r,t,n)}function he(e,t,n,r){return Z(e).eyeTiltToLookAtTilt(r,t,n)}function ge(t,n,r,o){if(i(n))return null;const s=t.renderSpatialReference,l=y(n.eye,s,N(t));return i(l)?null:a(o)?(o.position=l,o.heading=n.heading,o.tilt=n.tilt,o.fov=r,o):new e(l,n.heading,n.tilt,r)}function ye(e,t){var n;const r=null==(n=e.basemapTerrain)?void 0:n.tilingScheme;if(r)return r.levelAtScale(t);k.error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function Re(e,t){var n;const r=null==(n=e.basemapTerrain)?void 0:n.tilingScheme;if(r)return r.scaleAtLevel(t);k.error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}function xe(e,t){return e.spatialReference?j(t,e.spatialReference):void 0}function Me(t,n,r){const i=t.renderSpatialReference;let o,a;n||(n=t.state.camera);const s=M.WGS84;return n instanceof e?(o=n.position.latitude,h(n.position,G,i),h(r,O,i),a=u(G,O)):(g(n.center,i,O,s),o=O[1],a=n.distance),$(t,a,o)}class je{constructor(e){this.signal=e,this.resolver=s()}}function we(e){return e&&"resolver"in e}export{je as AsyncContext,Me as computeScale,te as directionToHeadingTilt,$ as distanceToScale,J as externalToInternal,ee as fromCenterDistance,_ as fromCenterScale,le as fromExtent,ae as getObserverForPointAtDistance,B as headingTiltToDirectionUp,Q as internalToExternal,ge as observerToCamera,V as scaleToDistance,xe as scaleToResolution,ye as scaleToZoom,ce as toExtent,Re as zoomToScale};
