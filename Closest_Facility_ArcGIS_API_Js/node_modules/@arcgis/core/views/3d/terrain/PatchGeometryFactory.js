/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{lerp as t}from"../../../core/mathUtils.js";import{isSome as e}from"../../../core/maybe.js";import{c as n}from"../../../chunks/vec3f64.js";import{s as o}from"../../../chunks/vec4.js";import{c as r}from"../../../chunks/vec4f64.js";import{empty as s}from"../../../geometry/support/aaBoundingBox.js";import{BufferPool as i}from"../../../geometry/support/buffer/BufferPool.js";import{newLayout as c}from"../support/buffer/InterleavedLayout.js";import{ElevationData as u}from"./ElevationData.js";import{MAX_PATCH_TESSELATION as f,GEOMETRY_VERTEX_STRIDE as a}from"./TerrainConst.js";import{computeNormal as m}from"../webgl-engine/materials/internal/MaterialUtil.js";const l=c().vec3f("position").vec2f("uv0"),g=new i((t=>l.createBuffer(t)),(t=>t.count));class p{constructor(){this.indices=null,this.vertexAttributes=null,this.boundingBox=s(),this.numSurfaceIndices=0,this.numSkirtIndices=0,this.numWithoutSkirtIndices=0,this.numVertsPerRow=0,this.skirtLength=0,this.uvOffsetAndScale=r()}}class h{constructor(t,e,n){this.values=t,this.numSurfaceIndices=e,this.numSkirtIndices=n}}function y(){g.clear(),V.clear()}function d(t){g.release(t.vertexAttributes),t.vertexAttributes=null,t.indices=null}const w=65536;function I(e,n,r,i,c,f,m,l){const p=c[0],h=c[1],y=c[2],d=c[3],w=.1*m.radius*(d-h),I=e.numVertsPerRow-1,v=e.numVertsPerRow-1,V=e.numVertsPerRow*e.numVertsPerRow,P=2*I+2*v,A=g.acquire(V+P),R=A.position.typedBuffer,j=A.uv0.typedBuffer,L=i.geometryInfo.boundingBox;s(L);const q=n[2]-n[0],O=n[3]-n[1],N=y-p,U=r[0],E=r[1],W=r[2];for(let t=0;t<=I;t++){const e=t/I,o=p+e*N;k[t]=Math.sin(o),B[t]=Math.cos(o),T[t]=e,D[t]=n[0]+e*q}const C=f&&!!(1&l),z=f&&!!(2&l);let F=0;for(let o=0;o<=v;o++){let r=o/v;const s=t(h,d,r),i=Math.cos(s),c=Math.sin(s);let l;f?(l=m.halfSemiMajorAxis*Math.log((1+c)/(1-c)),r=(l-n[1])/O):l=180*s/Math.PI;for(let t=0;t<=I;t++){const n=T[t],s=k[t],f=B[t];let g=m.radius;e.samplerData&&(g+=u.sample(D[t],l,e.samplerData)||0);const p=f*i*g-U,h=s*i*g-E,y=c*g-W;M(p,h,y,L);const d=a*F;R[d+0]=p,R[d+1]=h,R[d+2]=y,j[d+0]=n,j[d+1]=r;const x=b(t,o,I,v);if(x>-1){const t=a*(V+x),e=C&&0===o?-1:z&&o===v?1:0,s=0===e?p:-U,i=0===e?h:-E,c=0===e?y:m.radius*e-W;R[t+0]=s,R[t+1]=i,R[t+2]=c,j[t+0]=0===e?S(n,r):n,j[t+1]=0===e?w:r,0!==e&&M(s,i,c,L)}++F}}i.geometryInfo.numVertsPerRow=e.numVertsPerRow,i.geometryInfo.vertexAttributes=A,i.geometryInfo.skirtLength=w,o(i.geometryInfo.uvOffsetAndScale,0,0,1,1),x(i.geometryInfo,e.numVertsPerRow,f?l:0,e.wireframe),i.intersectionData=null}function v(t,n,r,i,c){const f=n[0],m=n[1],l=n[2]-f,p=n[3]-m,h=t.clippingArea,y=e(h)?Math.max(0,(h[0]-n[0])/l):0,d=e(h)?Math.max(0,(h[1]-n[1])/p):0,w=e(h)?Math.min(1,(h[2]-n[0])/l):1,I=e(h)?Math.min(1,(h[3]-n[1])/p):1,v=w>y?1/(w-y):1,V=I>d?1/(I-d):1,P=-y*v,A=-d*V,R=.1*l,j=t.numVertsPerRow-1,k=t.numVertsPerRow-1,B=t.numVertsPerRow*t.numVertsPerRow,T=2*j+2*k,D=g.acquire(B+T),L=D.position.typedBuffer,q=D.uv0.typedBuffer,O=c.geometryInfo.boundingBox;s(O);let N=0;for(let o=0;o<=k;o++){const n=o/k;let s=A+n*V,c=m+n*p;e(h)&&(c<h[1]?(c=h[1],s=0):c>h[3]&&(c=h[3],s=1));for(let m=0;m<=j;m++){const n=m/j;let g=P+n*v,p=f+n*l;e(h)&&(p<h[0]?(p=h[0],g=0):p>h[2]&&(p=h[2],g=1));const y=t.samplerData&&u.sample(p,c,t.samplerData)||0,d=p*i-r[0],w=c*i-r[1],I=y-r[2];M(d,w,I,O);const V=a*N;L[V+0]=d,L[V+1]=w,L[V+2]=I,q[V+0]=g,q[V+1]=s;const x=b(m,o,j,j);if(x>-1){const t=a*(B+x);L[t+0]=d,L[t+1]=w,L[t+2]=I,q[t+0]=S(g,s),q[t+1]=R}++N}}c.geometryInfo.numVertsPerRow=t.numVertsPerRow,c.geometryInfo.vertexAttributes=D,c.geometryInfo.skirtLength=R,o(c.geometryInfo.uvOffsetAndScale,y,d,w-y,I-d),x(c.geometryInfo,t.numVertsPerRow,0,t.wireframe)}const V=new Map;function x(t,e,n,o){const r=(2&n)>0,s=e+(o?1024:0)+(r?2048:0);let i=V.get(s);i||(i=P(e,r,o),V.set(s,i)),t.indices=i.values,t.numSurfaceIndices=i.numSurfaceIndices,t.numSkirtIndices=i.numSkirtIndices,t.numWithoutSkirtIndices=t.numSurfaceIndices+(n?6*(e-1)*(o?2:1):0)}function P(t,e,n){const o=t-1,r=t-1,s=t*t,i=2*o+2*r;let c=o*r*2*3,u=6*i,f=6*(2*o+r-1);n&&(c*=2,u*=2,f*=2);const a=s+i>w?new Uint32Array(c+u):new Uint16Array(c+u);let m,l,g,p,y=0,d=0,I=c,v=0;for(let h=0;h<=r;h++){e&&(v=0===h?f:h===r?-f:0),I+=v;for(let t=0;t<=o;t++){const e=b(t,h,o,r);if(e>-1){const i=A(t,h,o,r);0!==i&&(m=y,l=s+e,g=s+(0===t&&1===h?0:e+1),p=y+i,n?(a[I+0]=m,a[I+1]=l,a[I+2]=l,a[I+3]=g,a[I+4]=g,a[I+5]=m,a[I+6]=g,a[I+7]=p,a[I+8]=p,a[I+9]=m,a[I+10]=m,a[I+11]=g,I+=12):(a[I+0]=m,a[I+1]=l,a[I+2]=g,a[I+3]=g,a[I+4]=p,a[I+5]=m,I+=6))}++y,t<o&&h<r&&(m=h*(o+1)+t,l=m+1,g=l+(o+1),p=g-1,n?(a[d+0]=m,a[d+1]=l,a[d+2]=l,a[d+3]=g,a[d+4]=g,a[d+5]=m,a[d+6]=g,a[d+7]=p,a[d+8]=p,a[d+9]=m,a[d+10]=m,a[d+11]=g,d+=12):(a[d+0]=m,a[d+1]=l,a[d+2]=g,a[d+3]=g,a[d+4]=p,a[d+5]=m,d+=6))}I-=v}return new h(a,c,u)}function M(t,e,n,o){t<o[0]&&(o[0]=t),t>o[3]&&(o[3]=t),e<o[1]&&(o[1]=e),e>o[4]&&(o[4]=e),n<o[2]&&(o[2]=n),n>o[5]&&(o[5]=n)}function S(t,e){const n=e>t?1:0;return 2+4*n+(1-2*n)*(t+e)}function b(t,e,n,o){return 0===e?t:t===n?n+e:e===o?n+o+(n-t):0===t&&e>0?2*n+o+(o-e):-1}function A(t,e,n,o){return 0===e&&t!==n?1:t===n&&e!==o?n+1:e===o&&0!==t?-1:0===t&&0!==e?-(n+1):0}function R(t,n,o,r,s,i,c,u,f,a){const l=i.position,g=i.uv0,p=t[0],h=t[1],y=t[2],d=n[0]-p,w=n[1]-h,I=n[2]-y;r*=3;for(let v=o*=3;v<r;v+=3){const t=s[v],n=s[v+1],o=s[v+2];let r=l.get(t,0),i=l.get(t,1),V=l.get(t,2),x=l.get(n,0),P=l.get(n,1),M=l.get(n,2),S=l.get(o,0),b=l.get(o,1),A=l.get(o,2);if(g.get(t,0)>=2){const t=r+u[0],e=i+u[1],n=V+u[2],o=c/Math.sqrt(t*t+e*e+n*n);r+=t*o,i+=e*o,V+=n*o}if(g.get(n,0)>=2){const t=x+u[0],e=P+u[1],n=M+u[2],o=c/Math.sqrt(t*t+e*e+n*n);x+=t*o,P+=e*o,M+=n*o}if(g.get(o,0)>=2){const t=S+u[0],e=b+u[1],n=A+u[2],o=c/Math.sqrt(t*t+e*e+n*n);S+=t*o,b+=e*o,A+=n*o}e(f)&&([r,i,V]=f.applyToVertex(r,i,V),[x,P,M]=f.applyToVertex(x,P,M),[S,b,A]=f.applyToVertex(S,b,A));const R=x-r,j=P-i,k=M-V,B=S-r,T=b-i,D=A-V,q=w*D-T*I,O=I*B-D*d,N=d*T-B*w,U=R*q+j*O+k*N;if(Math.abs(U)<=Number.EPSILON)continue;const E=p-r,W=h-i,C=y-V,z=E*q+W*O+C*N;if(U>0){if(z<0||z>U)continue}else if(z>0||z<U)continue;const F=W*k-j*C,G=C*R-k*E,H=E*j-R*W,J=d*F+w*G+I*H;if(U>0){if(J<0||z+J>U)continue}else if(J>0||z+J<U)continue;const K=(B*F+T*G+D*H)/U;if(K>=0){a(K,m(R,j,k,B,T,D,L))}}}function j(t,n,o,r,s,i,c,u,f){const a=i.position,l=i.uv0,g=t[0],p=t[1],h=t[2],y=n[0]-g,d=n[1]-p,w=n[2]-h;r*=3;for(let I=o*=3;I<r;I+=3){const t=s[I],n=s[I+1],o=s[I+2];let r=a.get(t,0),i=a.get(t,1),v=a.get(t,2),V=a.get(n,0),x=a.get(n,1),P=a.get(n,2),M=a.get(o,0),S=a.get(o,1),b=a.get(o,2);l.get(t,0)>=2&&(v+=c);l.get(n,0)>=2&&(P+=c);l.get(o,0)>=2&&(b+=c),e(u)&&([r,i,v]=u.applyToVertex(r,i,v),[V,x,P]=u.applyToVertex(V,x,P),[M,S,b]=u.applyToVertex(M,S,b));const A=V-r,R=x-i,j=P-v,k=M-r,B=S-i,T=b-v,D=d*T-B*w,q=w*k-T*y,O=y*B-k*d,N=A*D+R*q+j*O;if(Math.abs(N)<=Number.EPSILON)continue;const U=g-r,E=p-i,W=h-v,C=U*D+E*q+W*O;if(N>0){if(C<0||C>N)continue}else if(C>0||C<N)continue;const z=E*j-R*W,F=W*A-j*U,G=U*R-A*E,H=y*z+d*F+w*G;if(N>0){if(H<0||C+H>N)continue}else if(H>0||C+H<N)continue;const J=(k*z+B*F+T*G)/N;if(J>=0){f(J,m(A,R,j,k,B,T,L))}}}const k=new Array(f+1),B=new Array(f+1),T=new Array(f+1),D=new Array(f+1),L=n();export{p as PatchGeometry,y as clearCaches,v as createPlanarGlobePatch,I as createSphericalGlobePatch,R as intersectSkirtsGlobal,j as intersectSkirtsLocal,d as releaseGeometry};
