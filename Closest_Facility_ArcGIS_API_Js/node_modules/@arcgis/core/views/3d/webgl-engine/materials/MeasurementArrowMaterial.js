/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{s as e,n as t,f as s,c as r,i,m as n}from"../../../../chunks/vec3.js";import{c as o}from"../../../../chunks/vec3f64.js";import{newLayout as a}from"../../support/buffer/InterleavedLayout.js";import c from"../lib/GLMaterial.js";import{Material as u,materialParametersDefaults as p}from"../lib/Material.js";import{MeasurementArrowTechniqueConfiguration as f,MeasurementArrowTechnique as l}from"../shaders/MeasurementArrowTechnique.js";class h extends u{constructor(e){super(e,d),this.techniqueConfig=new f}getTechniqueConfig(e){return this.techniqueConfig.polygonOffsetEnabled=this.params.polygonOffset,this.techniqueConfig.transparent=this.params.stripeEvenColor[3]<1||this.params.stripeOddColor[3]<1||this.params.outlineColor[3]<1,this.techniqueConfig.transparencyPassType=e?e.transparencyPassType:3,this.techniqueConfig}dispose(){}getPassParameters(){return this.params}intersect(){}createBufferWriter(){return new x}getGLMaterial(e){return 0===e.output?new m(e):void 0}}class m extends c{constructor(e){super(e),this.updateParameters()}updateParameters(e){this._technique=this._techniqueRep.releaseAndAcquire(l,this._material.getTechniqueConfig(e),this._technique)}beginSlot(e){return 3===e}bind(e){this._technique.bindPass(this._material.getPassParameters(),e)}}const d={width:32,outlineSize:.2,outlineColor:[1,.5,0,1],stripeLength:1,stripeEvenColor:[1,1,1,1],stripeOddColor:[1,.5,0,1],polygonOffset:!1,...p},g=a().vec3f("position").vec3f("normal").vec2f("uv0").f32("auxpos1"),v=o(),C=o(),q=o(),y=o(),b=o();class x{constructor(){this.vertexBufferLayout=g}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 2*(e.indices.get("position").length/2+1)}write(o,a,c,u){const p=a.vertexAttributes.get("position").data,f=a.vertexAttributes.get("normal").data,l=p.length/3,h=a&&a.indices&&a.indices.get("position");h&&h.length!==2*(l-1)&&console.warn("MeasurementArrowMaterial does not support indices");const m=v,d=C,g=q,x=y,P=b,w=o.transformation,T=o.invTranspTransformation,j=c.position,A=c.normal,L=c.uv0;let M=0;for(let v=0;v<l;++v){const o=3*v;if(e(m,p[o],p[o+1],p[o+2]),v<l-1){const i=3*(v+1);e(d,p[i],p[i+1],p[i+2]),e(P,f[i],f[i+1],f[i+2]),t(P,P),s(g,d,m),t(g,g),r(x,P,g),t(x,x)}const a=i(m,d);w&&T&&(n(m,m,w),n(d,d,w),n(x,x,T));const c=u+2*v,h=c+1;j.setVec(c,m),j.setVec(h,m),A.setVec(c,x),A.setVec(h,x),L.set(c,0,M),L.set(c,1,-1),L.set(h,0,M),L.set(h,1,1),v<l-1&&(M+=a)}const _=c.auxpos1;for(let e=0;e<2*l;++e)_.set(u+e,M)}}export{h as MeasurementArrowMaterial};
