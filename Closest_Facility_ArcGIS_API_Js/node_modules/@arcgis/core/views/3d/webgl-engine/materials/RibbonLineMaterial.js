/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import e from"../../../../core/Logger.js";import{clamp as t}from"../../../../core/mathUtils.js";import{isSome as i}from"../../../../core/maybe.js";import{createRenderScreenPointArray3 as s}from"../../../../core/screenUtils.js";import{c as r}from"../../../../chunks/vec2.js";import{s as n,f as a,d as o,a as u,b as l,g as c,l as p,i as h,m}from"../../../../chunks/vec3.js";import{c as f}from"../../../../chunks/vec3f64.js";import{create as d,distance2 as v,fromPoints as b,closestLineSegmentPoint as g}from"../../../../geometry/support/lineSegment.js";import{create as C,fromPoints as q,signedDistance as S,normal as A}from"../../../../geometry/support/plane.js";import{newLayout as y}from"../../support/buffer/InterleavedLayout.js";import{computeAttachmentOriginLines as x}from"../lib/geometryDataUtils.js";import z from"../lib/GLMaterial.js";import{materialParametersDefaults as E,Material as j}from"../lib/Material.js";import{isTranslationMatrix as P}from"../lib/Util.js";import O from"./VisualVariableMaterialParameters.js";import{isInstanceHidden as L}from"./renderers/utils.js";import{ribbonVertexAttributeLocations as _,RibbonLineTechniqueConfiguration as R,RibbonLineTechnique as w}from"../shaders/RibbonLineTechnique.js";const T=e.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial");class M extends j{constructor(e){super(e,D),this._vertexAttributeLocations=_,this.techniqueConfig=new R,this.layout=this.createLayout()}isClosed(e,t){return B(this.params,e,t)}dispose(){}getPassParameters(){return this.params}getTechniqueConfig(e,t){this.techniqueConfig.output=e;const s=i(t)&&23===t.slot;this.techniqueConfig.draped=s;const r=i(this.params.stipplePattern);return this.techniqueConfig.stippleEnabled=r,this.techniqueConfig.stippleIntegerRepeatsEnabled=r&&this.params.stippleIntegerRepeats,this.techniqueConfig.stippleOffColorEnabled=r&&i(this.params.stippleOffColor),this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,this.techniqueConfig.roundJoins="round"===this.params.join,this.techniqueConfig.roundCaps="round"===this.params.cap,this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.polygonOffset=this.params.polygonOffset,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.vvColor=this.params.vvColorEnabled,this.techniqueConfig.vvOpacity=this.params.vvOpacityEnabled,this.techniqueConfig.vvSize=this.params.vvSizeEnabled,this.techniqueConfig.innerColorEnabled=this.params.innerWidth>0&&i(this.params.innerColor),this.techniqueConfig.falloffEnabled=this.params.falloff>0,this.techniqueConfig.occluder=8===this.params.renderOccluded,this.techniqueConfig.transparencyPassType=t?t.transparencyPassType:3,this.techniqueConfig.multipassTerrainEnabled=!!t&&t.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=!!t&&t.cullAboveGround,this.techniqueConfig}intersect(e,t,i,s,r,n,a,o,u){u?this.intersectDrapedLineGeometry(e,s,n,a):this.intersectLineGeometry(e,t,i,s,this.params.width,a)}intersectDrapedLineGeometry(e,i,s,r){if(!i.options.selectionMode)return;const n=e.vertexAttributes.get("position").data,a=e.vertexAttributes.get("size");let o=this.params.width;if(this.params.vvSizeEnabled){const i=e.vertexAttributes.get("sizeFeatureAttribute").data[0];o*=t(this.params.vvSizeOffset[0]+i*this.params.vvSizeFactor[0],this.params.vvSizeMinSize[0],this.params.vvSizeMaxSize[0])}else a&&(o*=a.data[0]);const u=s[0],l=s[1],c=(o/2+4)*e.screenToWorldRatio;let p=Number.MAX_VALUE;for(let h=0;h<n.length-5;h+=3){const e=n[h],i=n[h+1],s=u-e,r=l-i,a=n[h+3]-e,o=n[h+4]-i,c=t((a*s+o*r)/(a*a+o*o),0,1),m=a*c-s,f=o*c-r,d=m*m+f*f;d<p&&(p=d)}p<c*c&&r()}intersectLineGeometry(e,i,s,m,f,d){if(!m.options.selectionMode||L(i))return;if(!P(s))return void T.error("intersection assumes a translation-only matrix");const C=e.vertexAttributes,y=C.get("position").data;let x=f;if(this.params.vvSizeEnabled){const e=C.get("sizeFeatureAttribute").data[0];x*=t(this.params.vvSizeOffset[0]+e*this.params.vvSizeFactor[0],this.params.vvSizeMinSize[0],this.params.vvSizeMaxSize[0])}else C.has("size")&&(x*=C.get("size").data[0]);const z=m.camera,E=X;r(E,m.point);const j=x*z.pixelRatio/2+4*z.pixelRatio;n(re[0],E[0]-j,E[1]+j,0),n(re[1],E[0]+j,E[1]+j,0),n(re[2],E[0]+j,E[1]-j,0),n(re[3],E[0]-j,E[1]-j,0);for(let t=0;t<4;t++)if(!z.unprojectFromRenderScreen(re[t],ne[t]))return;q(z.eye,ne[0],ne[1],ae),q(z.eye,ne[1],ne[2],oe),q(z.eye,ne[2],ne[3],ue),q(z.eye,ne[3],ne[0],le);let O=Number.MAX_VALUE;const _=V(this.params,C,e.indices)?y.length-2:y.length-5;for(let t=0;t<_;t+=3){W[0]=y[t]+s[12],W[1]=y[t+1]+s[13],W[2]=y[t+2]+s[14];const e=(t+3)%y.length;if(k[0]=y[e]+s[12],k[1]=y[e+1]+s[13],k[2]=y[e+2]+s[14],S(ae,W)<0&&S(ae,k)<0||S(oe,W)<0&&S(oe,k)<0||S(ue,W)<0&&S(ue,k)<0||S(le,W)<0&&S(le,k)<0)continue;if(z.projectToRenderScreen(W,K),z.projectToRenderScreen(k,Q),K[2]<0&&Q[2]>0){a(I,W,k);const e=z.frustum,t=-S(e[4],W)/o(I,A(e[4]));u(I,I,t),l(W,W,I),z.projectToRenderScreen(W,K)}else if(K[2]>0&&Q[2]<0){a(I,k,W);const e=z.frustum,t=-S(e[4],k)/o(I,A(e[4]));u(I,I,t),l(k,k,I),z.projectToRenderScreen(k,Q)}else if(K[2]<0&&Q[2]<0)continue;K[2]=0,Q[2]=0;const i=v(b(K,Q,$),E);i<O&&(O=i,c(Y,W),c(Z,k))}const R=m.rayBeginPoint,w=m.rayEndPoint;if(O<j*j){let e=Number.MAX_VALUE;if(g(b(Y,Z,$),b(R,w,ee),N)){a(N,N,R);const t=p(N);u(N,N,1/t),e=t/h(R,w)}d(e,N)}}computeAttachmentOrigin(e,t){const i=e.vertexAttributes;if(!i)return null;const s=e.indices,r=i.get("position");return x(r,s?s.get("position"):null,s&&V(this.params,i,s),t)}createLayout(){const e=y().vec3f("position").f32("subdivisionFactor").vec2f("uv0").vec3f("auxpos1").vec3f("auxpos2");return this.params.vvSizeEnabled?e.f32("sizeFeatureAttribute"):e.f32("size"),this.params.vvColorEnabled?e.f32("colorFeatureAttribute"):e.vec4f("color"),this.params.vvOpacityEnabled&&e.f32("opacityFeatureAttribute"),e}createBufferWriter(){return new G(this.layout,this.params)}getGLMaterial(e){return 0===e.output||7===e.output||4===e.output||1===e.output?new F(e):void 0}validateParameterValues(e){"miter"!==e.join&&(e.miterLimit=0),this.requiresTransparent(e)&&(e.transparent=!0)}requiresTransparent(e){return!!((e.color&&e.color[3])<1||e.innerWidth>0&&this.colorRequiresTransparent(e.innerColor)||e.stipplePattern&&this.colorRequiresTransparent(e.stippleOffColor)||e.falloff>0)}colorRequiresTransparent(e){return i(e)&&e[3]<1&&e[3]>0}}class F extends z{constructor(e){super(e),this.updateParameters()}updateParameters(e){this._technique=this._techniqueRep.releaseAndAcquire(w,this._material.getTechniqueConfig(this._output,e),this._technique)}beginSlot(e){return 23===e||(this._technique.configuration.occluder?3===e||10===e||11===e:0===this._output||7===this._output?(this.targetSlot=this._technique.configuration.writeDepth?5:8,e===this.targetSlot):3===e)}_updateOccludeeState(e){e.hasOccludees!==this._material.params.sceneHasOcludees&&this._material.setParameterValues({sceneHasOcludees:e.hasOccludees})}ensureParameters(e){0!==this._output&&7!==this._output||this._updateOccludeeState(e),this.updateParameters(e)}bind(e){this._technique.bindPass(this._material.getPassParameters(),e)}getPipelineState(e,t){return this._technique.getPipelineState(e,t)}}const D={width:0,color:[1,1,1,1],join:"miter",cap:"butt",miterLimit:5,writeDepth:!0,polygonOffset:!1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null,slicePlaneEnabled:!1,vvFastUpdate:!1,transparent:!1,isClosed:!1,falloff:0,innerWidth:0,innerColor:null,sceneHasOcludees:!1,...E,...O.Default};class G{constructor(e,t){switch(this.params=t,this.numJoinSubdivisions=0,this.vertexBufferLayout=e,this.params.join){case"miter":case"bevel":this.numJoinSubdivisions=t.stipplePattern?1:0;break;case"round":this.numJoinSubdivisions=H}}isClosed(e){return V(this.params,e.vertexAttributes,e.indices)}numCapSubdivisions(e){if(this.isClosed(e))return 0;switch(this.params.cap){case"butt":return 0;case"square":return 1;case"round":return J}}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){const t=2*this.numCapSubdivisions(e)+2,i=e.indices.get("position").length/2+1,s=this.isClosed(e);let r=s?2:2*t;const n=s?0:1,a=s?i:i-1;if(e.vertexAttributes.has("subdivisions")){const t=e.vertexAttributes.get("subdivisions").data;for(let e=n;e<a;++e){r+=4+2*t[e]}}else{r+=(a-n)*(2*this.numJoinSubdivisions+4)}return r+=2,r}write(e,t,i,s){const r=te,a=ie,o=se,u=t.vertexAttributes.get("position").data,l=t.indices&&t.indices.get("position"),p=this.numCapSubdivisions(t);l&&l.length!==2*(u.length/3-1)&&console.warn("RibbonLineMaterial does not support indices");let f=null;t.vertexAttributes.has("subdivisions")&&(f=t.vertexAttributes.get("subdivisions").data);let d=1,v=0;this.params.vvSizeEnabled?v=t.vertexAttributes.get("sizeFeatureAttribute").data[0]:t.vertexAttributes.has("size")&&(d=t.vertexAttributes.get("size").data[0]);let b=[1,1,1,1],g=0;this.params.vvColorEnabled?g=t.vertexAttributes.get("colorFeatureAttribute").data[0]:t.vertexAttributes.has("color")&&(b=t.vertexAttributes.get("color").data);let C=0;this.params.vvOpacityEnabled&&(C=t.vertexAttributes.get("opacityFeatureAttribute").data[0]);const q=u.length/3,S=e.transformation,A=new Float32Array(i.buffer),y=this.vertexBufferLayout.stride/4;let x=s*y;const z=x;let E=0;const j=(e,t,i,s,r,n,a,o)=>{if(A[x++]=t[0],A[x++]=t[1],A[x++]=t[2],A[x++]=s,A[x++]=o,A[x++]=n+r/10,A[x++]=e[0],A[x++]=e[1],A[x++]=e[2],A[x++]=i[0],A[x++]=i[1],A[x++]=i[2],this.params.vvSizeEnabled?A[x++]=v:A[x++]=d,this.params.vvColorEnabled)A[x++]=g;else{const e=Math.min(4*a,b.length-4);A[x++]=b[e+0],A[x++]=b[e+1],A[x++]=b[e+2],A[x++]=b[e+3]}this.params.vvOpacityEnabled&&(A[x++]=C)};x+=y,n(a,u[0],u[1],u[2]),S&&m(a,a,S);const P=this.isClosed(t);if(P){const e=u.length-3;n(r,u[e],u[e+1],u[e+2]),S&&m(r,r,S)}else{c(r,a),n(o,u[3],u[4],u[5]),S&&m(o,o,S);for(let e=0;e<p;++e){const t=1-e/p;j(r,a,o,t,1,-4,0,E),j(r,a,o,t,1,4,0,E)}j(r,a,o,0,0,-4,0,E),j(r,a,o,0,0,4,0,E),c(r,a),c(a,o)}const O=P?0:1,L=P?q:q-1;for(let _=O;_<L;_++){const e=(_+1)%q*3;n(o,u[e+0],u[e+1],u[e+2]),S&&m(o,o,S),E+=h(r,a),j(r,a,o,0,1,-1,_,E),j(r,a,o,0,1,1,_,E);const t=f?f[_]:this.numJoinSubdivisions;for(let i=0;i<t;++i){const e=(i+1)/(t+1);j(r,a,o,e,1,-2,_,E),j(r,a,o,e,1,2,_,E)}j(r,a,o,1,0,-2,_,E),j(r,a,o,1,0,2,_,E),c(r,a),c(a,o)}if(P)n(o,u[3],u[4],u[5]),S&&m(o,o,S),E+=h(r,a),j(r,a,o,0,1,-1,O,E),j(r,a,o,0,1,1,O,E);else{E+=h(r,a),j(r,a,o,0,1,-5,L,E),j(r,a,o,0,1,5,L,E);for(let e=0;e<p;++e){const t=(e+1)/p;j(r,a,o,t,1,-5,L,E),j(r,a,o,t,1,5,L,E)}}U(A,z+y,A,z,y);x=U(A,x-y,A,x,y)}}function U(e,t,i,s,r){for(let n=0;n<r;n++)i[s++]=e[t++];return s}function V(e,t,i){return B(e,t.get("position").data,i?i.get("position"):null)}function B(e,t,i){return!!e.isClosed&&(i?i.length>2:t.length>6)}const J=3,H=1,W=f(),k=f(),I=f(),N=f(),X=f(),K=s(),Q=s(),Y=f(),Z=f(),$=d(),ee=d(),te=f(),ie=f(),se=f(),re=[s(),s(),s(),s()],ne=[f(),f(),f(),f()],ae=C(),oe=C(),ue=C(),le=C();export{M as RibbonLineMaterial};
