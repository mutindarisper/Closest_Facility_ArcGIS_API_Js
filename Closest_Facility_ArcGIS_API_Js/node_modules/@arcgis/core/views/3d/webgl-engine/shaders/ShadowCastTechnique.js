/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{_ as i}from"../../../../chunks/tslib.es6.js";import{ReloadableShaderModule as r}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as t}from"../core/shaderTechnique/ShaderTechnique.js";import{parameter as e,ShaderTechniqueConfiguration as o}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{Default3D as s}from"../lib/DefaultVertexAttributeLocations.js";import{blendingDefault as a}from"../lib/OrderIndependentTransparency.js";import{Program as n}from"../lib/Program.js";import{S as p}from"../../../../chunks/ShadowCast.glsl.js";import{makePipelineState as h,separateBlendingParams as l,defaultColorWriteParams as m}from"../../../webgl/renderState.js";class d extends t{initializeProgram(i){const r=d.shader.get().build(this.configuration);return new n(i.rctx,r,s)}initializePipeline(i){return 0===this.configuration.pass?h({blending:l(1,1,1,1),colorWrite:m,depthTest:null,depthWrite:null}):1===this.configuration.pass||2===this.configuration.pass?h({blending:a,colorWrite:m,depthTest:null,depthWrite:null}):h({})}bindPass(i){if(0===this.configuration.pass||2===this.configuration.pass){const r=i;this.program.bindTexture(r.linearDepthTexture,"depthMap"),r.shadowMap.bind(this.program),r.shadowMap.bindView(this.program,r.camera.center),this.program.setUniform2fv("nearFar",r.camera.nearFar),this.program.setUniformMatrix4fv("inverseView",r.inverseView),this.program.setUniform4fv("projInfo",r.projInfo),this.program.setUniform2fv("zScale",r.zScale)}else if(1===this.configuration.pass){const r=i;if(this.program.bindTexture(r.shadowCastMap,"shadowCastMap"),this.program.setUniform1f("sampleScale",r.sampleScale),this.program.setUniform1f("opacityFromElevation",r.opacityFromElevation),this.program.setUniform4fv("color",r.color),0===this.configuration.visualization&&this.configuration.bandsEnabled){const r=i;this.program.setUniform1f("bandSize",r.bandSize)}else if(1===this.configuration.visualization){const r=i;this.program.setUniform1f("threshold",r.threshold)}}}get primitiveType(){return 5}}d.shader=new r(p,(()=>import("./ShadowCast.glsl.js")));class c extends o{constructor(){super(...arguments),this.pass=0,this.visualization=0,this.bandsEnabled=!1}}i([e({count:3})],c.prototype,"pass",void 0),i([e()],c.prototype,"visualization",void 0),i([e()],c.prototype,"bandsEnabled",void 0);export{d as ShadowCastTechnique,c as ShadowCastTechniqueConfiguration};
