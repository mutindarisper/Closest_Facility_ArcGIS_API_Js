/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.21/esri/copyright.txt for details.
*/
import{unwrap as e}from"../../../core/maybe.js";import{j as t}from"../../../chunks/vec2.js";import{a as r}from"../../../chunks/vec2f64.js";import{defaults as i}from"./Settings.js";import{SnappingAlgorithm as o}from"./SnappingAlgorithm.js";import{anyMapPointToScreenPoint as s,squareDistance as n}from"./snappingUtils.js";import{ParallelLineSnappingCandidate as l}from"./candidates/ParallelLineSnappingCandidate.js";import{projectPointToLine as a}from"../../support/geometry2dUtils.js";class c extends o{constructor(){super(...arguments),this._tmpProjection=r()}snapNewVertex(e,t){const r=t.editGeometryOperations.data.components[0],i=r.edges.length,o=r.vertices.length,n=[];if(i<2)return n;const l=s(e,t.coordinateHelper,t.elevationInfo,this.view),a=r.vertices[o-1],c=r.vertices[0],h=r.edges[i-1];let p=h;do{this.edgeExceedsShortLineThreshold(p,t)&&(this._checkEdgeForParalleLines(p,a.pos,e,l,t,n),this._checkEdgeForParalleLines(p,c.pos,e,l,t,n)),p=p.leftVertex.leftEdge}while(p&&p!==h);return n}snapExistingVertex(t,r){const i=[],o=e(r.vertexHandle),n=o.component;if(n.edges.length<3)return i;const l=s(t,r.coordinateHelper,r.elevationInfo,this.view),a=o.leftEdge,c=o.rightEdge,h=n.vertices[0],p=n.vertices.length,d=n.vertices[p-1],g=n.edges[0];let m=g;do{m!==a&&m!==c&&this.edgeExceedsShortLineThreshold(m,r)&&(a&&this._checkEdgeForParalleLines(m,a.leftVertex.pos,t,l,r,i),c&&this._checkEdgeForParalleLines(m,c.rightVertex.pos,t,l,r,i),o===h?this._checkEdgeForParalleLines(m,d.pos,t,l,r,i):o===d&&this._checkEdgeForParalleLines(m,h.pos,t,l,r,i)),m=m.rightVertex.rightEdge}while(m&&m!==g);return i}_checkEdgeForParalleLines(e,r,o,c,h,p){const d=e.leftVertex.pos,g=e.rightVertex.pos;if(a(this._tmpProjection,r,d,g),t(this._tmpProjection,r)<i.parallelLineThreshold)return;a(this._tmpProjection,o,d,g,r);const m=h.coordinateHelper,f=m.fromXYZ(this._tmpProjection,m.getZ(o,0));if(n(c,s(f,m,h.elevationInfo,this.view))<this.squaredProximityTreshold(h.pointer)){if(this.parallelToPreviousCandidate(e,p))return;p.push(new l({coordinateHelper:m,referenceLine:e,lineStart:r,targetPoint:f}))}}parallelToPreviousCandidate(e,r){const o=e.leftVertex.pos,s=e.rightVertex.pos;for(const n of r)if(a(this._tmpProjection,s,n.constraint.start,n.constraint.end,o),t(this._tmpProjection,s)<i.parallelLineThreshold)return n.addReferenceLine(e),!0;return!1}}export{c as ParallelLineSnapper};
